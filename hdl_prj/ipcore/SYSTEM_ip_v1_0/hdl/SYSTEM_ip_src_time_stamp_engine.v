// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\tb_SYSTEM\SYSTEM_ip_src_time_stamp_engine.v
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SYSTEM_ip_src_time_stamp_engine
// Source Path: tb_SYSTEM/SYSTEM/time_stamp_engine
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SYSTEM_ip_src_time_stamp_engine
          (clk,
           reset_x,
           tstamp_ready,
           tstamp_value,
           tstamp_strobe,
           time_stamp_tick);


  input   clk;
  input   reset_x;
  input   tstamp_ready;
  input   [63:0] tstamp_value;  // ufix64
  output  tstamp_strobe;
  output  [63:0] time_stamp_tick;  // ufix64


  wire [15:0] Constant_out1;  // uint16
  wire [15:0] Constant2_out1;  // uint16
  wire HDL_Counter1_ctrl_const_out;
  reg  HDL_Counter1_ctrl_delay_out;
  wire [23:0] HDL_Counter1_Initial_Val_out;  // ufix24
  wire [23:0] count_step;  // ufix24
  wire [23:0] HDL_Counter1_out1;  // ufix24
  wire [23:0] count;  // ufix24
  reg [23:0] HDL_Counter1_out;  // ufix24
  wire Compare_To_Constant1_out1;
  reg  Unit_Delay8_out1;
  wire [63:0] count_step_1;  // ufix64
  reg  Unit_Delay5_out1;
  reg  [0:2] Delay1_reg;  // ufix1 [3]
  wire [0:2] Delay1_reg_next;  // ufix1 [3]
  wire Delay1_out1;
  reg [63:0] Unit_Delay6_out1;  // ufix64
  reg [63:0] latch1_out1;  // ufix64
  wire [63:0] Constant1_out1;  // ufix64
  wire AND_out1;
  reg [63:0] HDL_Counter_out1;  // ufix64
  reg [63:0] latch0_out1;  // ufix64
  wire signed [63:0] Subtract1_1;  // sfix64
  wire signed [63:0] Subtract1_2;  // sfix64
  wire signed [63:0] Subtract1_out1;  // sfix64
  reg signed [63:0] Unit_Delay7_out1;  // sfix64
  reg signed [63:0] latch2_out1;  // sfix64
  wire signed [64:0] Subtract2_add_temp;  // sfix65
  wire signed [64:0] Subtract2_1;  // sfix65
  wire signed [64:0] Subtract2_2;  // sfix65
  wire signed [63:0] Subtract2_out1;  // sfix64
  reg signed [63:0] Unit_Delay10_out1;  // sfix64
  reg signed [63:0] Unit_Delay2_out1;  // sfix64
  reg [63:0] Unit_Delay1_out1;  // ufix64
  wire signed [63:0] Subtract3_stage2_add_cast;  // sfix64
  wire signed [64:0] Subtract3_stage2_add_cast_1;  // sfix65
  wire signed [64:0] Subtract3_stage2_add_temp;  // sfix65
  wire signed [63:0] Subtract3_stage2_cast;  // sfix64
  wire signed [64:0] Subtract3_stage2_1;  // sfix65
  wire signed [64:0] Subtract3_op_stage1;  // sfix65
  wire signed [63:0] Subtract3_stage3_add_cast;  // sfix64
  wire signed [64:0] Subtract3_stage3_add_cast_1;  // sfix65
  wire signed [63:0] Subtract3_stage3_add_cast_2;  // sfix64
  wire signed [64:0] Subtract3_stage3_add_cast_3;  // sfix65
  wire signed [64:0] Subtract3_stage3_add_temp;  // sfix65
  wire signed [63:0] Subtract3_stage3_cast;  // sfix64
  wire [63:0] Subtract3_out1;  // ufix64
  reg [63:0] Unit_Delay3_out1;  // ufix64
  wire [63:0] count_1;  // ufix64
  wire [63:0] count_2;  // ufix64
  wire [20:0] Extract_Bits_out1;  // ufix21
  wire Compare_To_Constant_out1;
  wire [15:0] valuedeadOutdeadOut;  // uint16
  wire valid;
  wire NOT_out1;
  reg  Unit_Delay9_out1;
  wire [15:0] valuedeadOutdeadOut_1;  // uint16
  wire valid_1;
  reg  Unit_Delay4_out1;
  wire [63:0] TS_REG_out1;  // ufix64

  // load accumulator asynchronously 
  // with larger period = 0.13 sec
  // pulse длительностью 100мкс каждые 1000мкс, 
  // но только через 500мкс после предыдущего импульса
  // нужно, чтобы если поправка = 0, 
  // то значение счетчика не поменялось
  // т.о учитываем 2 такта задержек и 
  // 1 такт на загрузку счетчика


  assign Constant_out1 = 16'b0011000011010100;


  assign Constant2_out1 = 16'b0000000000000000;


  assign HDL_Counter1_ctrl_const_out = 1'b1;



  always @(posedge clk or posedge reset_x)
    begin : HDL_Counter1_ctrl_delay_process
      if (reset_x == 1'b1) begin
        HDL_Counter1_ctrl_delay_out <= 1'b0;
      end
      else begin
        HDL_Counter1_ctrl_delay_out <= HDL_Counter1_ctrl_const_out;
      end
    end



  assign HDL_Counter1_Initial_Val_out = 24'b000000000000000000000001;



  // Free running, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  assign count_step = 24'b000000000000000000000001;


  assign count = HDL_Counter1_out1 + count_step;


  always @(posedge clk or posedge reset_x)
    begin : HDL_Counter1_process
      if (reset_x == 1'b1) begin
        HDL_Counter1_out <= 24'b000000000000000000000000;
      end
      else begin
        HDL_Counter1_out <= count;
      end
    end


  assign HDL_Counter1_out1 = (HDL_Counter1_ctrl_delay_out == 1'b0 ? HDL_Counter1_Initial_Val_out :
              HDL_Counter1_out);



  assign Compare_To_Constant1_out1 = HDL_Counter1_out1 == 24'b000000000000000000000000;


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay8_process
      if (reset_x == 1'b1) begin
        Unit_Delay8_out1 <= 1'b0;
      end
      else begin
        Unit_Delay8_out1 <= Compare_To_Constant1_out1;
      end
    end


  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = 8
  assign count_step_1 = 64'h0000000000000008;


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay5_process
      if (reset_x == 1'b1) begin
        Unit_Delay5_out1 <= 1'b0;
      end
      else begin
        Unit_Delay5_out1 <= tstamp_ready;
      end
    end


  always @(posedge clk or posedge reset_x)
    begin : Delay1_process
      if (reset_x == 1'b1) begin
        Delay1_reg[0] <= 1'b0;
        Delay1_reg[1] <= 1'b0;
        Delay1_reg[2] <= 1'b0;
      end
      else begin
        Delay1_reg[0] <= Delay1_reg_next[0];
        Delay1_reg[1] <= Delay1_reg_next[1];
        Delay1_reg[2] <= Delay1_reg_next[2];
      end
    end

  assign Delay1_out1 = Delay1_reg[2];
  assign Delay1_reg_next[0] = Unit_Delay5_out1;
  assign Delay1_reg_next[1] = Delay1_reg[0];
  assign Delay1_reg_next[2] = Delay1_reg[1];


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay6_process
      if (reset_x == 1'b1) begin
        Unit_Delay6_out1 <= 64'h0000000000000000;
      end
      else begin
        Unit_Delay6_out1 <= tstamp_value;
      end
    end


  always @(posedge clk or posedge reset_x)
    begin : latch1_process
      if (reset_x == 1'b1) begin
        latch1_out1 <= 64'h0000000000000000;
      end
      else begin
        if (Unit_Delay5_out1) begin
          latch1_out1 <= Unit_Delay6_out1;
        end
      end
    end


  assign Constant1_out1 = 64'h0000000000000018;


  always @(posedge clk or posedge reset_x)
    begin : latch0_process
      if (reset_x == 1'b1) begin
        latch0_out1 <= 64'h0000000000000000;
      end
      else begin
        if (AND_out1) begin
          latch0_out1 <= HDL_Counter_out1;
        end
      end
    end


  assign Subtract1_1 = latch1_out1;
  assign Subtract1_2 = latch0_out1;
  assign Subtract1_out1 = Subtract1_1 - Subtract1_2;


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay7_process
      if (reset_x == 1'b1) begin
        Unit_Delay7_out1 <= 64'sh0000000000000000;
      end
      else begin
        Unit_Delay7_out1 <= Subtract1_out1;
      end
    end


  assign Subtract2_1 = {Unit_Delay7_out1[63], Unit_Delay7_out1};
  assign Subtract2_2 = {latch2_out1[63], latch2_out1};
  assign Subtract2_add_temp = Subtract2_1 + Subtract2_2;
  assign Subtract2_out1 = ((Subtract2_add_temp[64] == 1'b0) && (Subtract2_add_temp[63] != 1'b0) ? 64'sh7FFFFFFFFFFFFFFF :
              ((Subtract2_add_temp[64] == 1'b1) && (Subtract2_add_temp[63] != 1'b1) ? 64'sh8000000000000000 :
              $signed(Subtract2_add_temp[63:0])));


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay10_process
      if (reset_x == 1'b1) begin
        Unit_Delay10_out1 <= 64'sh0000000000000000;
      end
      else begin
        Unit_Delay10_out1 <= Subtract2_out1;
      end
    end


  always @(posedge clk or posedge reset_x)
    begin : latch2_process
      if (reset_x == 1'b1) begin
        latch2_out1 <= 64'sh0000000000000000;
      end
      else begin
        if (Delay1_out1) begin
          latch2_out1 <= Unit_Delay10_out1;
        end
      end
    end


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay2_process
      if (reset_x == 1'b1) begin
        Unit_Delay2_out1 <= 64'sh0000000000000000;
      end
      else begin
        Unit_Delay2_out1 <= latch2_out1;
      end
    end


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay1_process
      if (reset_x == 1'b1) begin
        Unit_Delay1_out1 <= 64'h0000000000000000;
      end
      else begin
        Unit_Delay1_out1 <= HDL_Counter_out1;
      end
    end


  assign Subtract3_stage2_add_cast = (Unit_Delay1_out1[63] != 1'b0 ? 64'sh7FFFFFFFFFFFFFFF :
              Unit_Delay1_out1);
  assign Subtract3_stage2_add_cast_1 = {Subtract3_stage2_add_cast[63], Subtract3_stage2_add_cast};
  assign Subtract3_stage2_1 = {Unit_Delay2_out1[63], Unit_Delay2_out1};
  assign Subtract3_stage2_add_temp = Subtract3_stage2_add_cast_1 + Subtract3_stage2_1;
  assign Subtract3_stage2_cast = ((Subtract3_stage2_add_temp[64] == 1'b0) && (Subtract3_stage2_add_temp[63] != 1'b0) ? 64'sh7FFFFFFFFFFFFFFF :
              ((Subtract3_stage2_add_temp[64] == 1'b1) && (Subtract3_stage2_add_temp[63] != 1'b1) ? 64'sh8000000000000000 :
              $signed(Subtract3_stage2_add_temp[63:0])));
  assign Subtract3_op_stage1 = {Subtract3_stage2_cast[63], Subtract3_stage2_cast};



  assign Subtract3_stage3_add_cast = ((Subtract3_op_stage1[64] == 1'b0) && (Subtract3_op_stage1[63] != 1'b0) ? 64'sh7FFFFFFFFFFFFFFF :
              ((Subtract3_op_stage1[64] == 1'b1) && (Subtract3_op_stage1[63] != 1'b1) ? 64'sh8000000000000000 :
              $signed(Subtract3_op_stage1[63:0])));
  assign Subtract3_stage3_add_cast_1 = {Subtract3_stage3_add_cast[63], Subtract3_stage3_add_cast};
  assign Subtract3_stage3_add_cast_2 = (Constant1_out1[63] != 1'b0 ? 64'sh7FFFFFFFFFFFFFFF :
              Constant1_out1);
  assign Subtract3_stage3_add_cast_3 = {Subtract3_stage3_add_cast_2[63], Subtract3_stage3_add_cast_2};
  assign Subtract3_stage3_add_temp = Subtract3_stage3_add_cast_1 + Subtract3_stage3_add_cast_3;
  assign Subtract3_stage3_cast = ((Subtract3_stage3_add_temp[64] == 1'b0) && (Subtract3_stage3_add_temp[63] != 1'b0) ? 64'sh7FFFFFFFFFFFFFFF :
              ((Subtract3_stage3_add_temp[64] == 1'b1) && (Subtract3_stage3_add_temp[63] != 1'b1) ? 64'sh8000000000000000 :
              $signed(Subtract3_stage3_add_temp[63:0])));
  assign Subtract3_out1 = (Subtract3_stage3_cast[63] == 1'b1 ? 64'h0000000000000000 :
              Subtract3_stage3_cast);


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay3_process
      if (reset_x == 1'b1) begin
        Unit_Delay3_out1 <= 64'h0000000000000000;
      end
      else begin
        Unit_Delay3_out1 <= Subtract3_out1;
      end
    end


  assign count_1 = HDL_Counter_out1 + count_step_1;


  assign count_2 = (Unit_Delay8_out1 == 1'b0 ? count_1 :
              Unit_Delay3_out1);


  always @(posedge clk or posedge reset_x)
    begin : HDL_Counter_process
      if (reset_x == 1'b1) begin
        HDL_Counter_out1 <= 64'h0000000000000000;
      end
      else begin
        HDL_Counter_out1 <= count_2;
      end
    end


  assign Extract_Bits_out1 = HDL_Counter_out1[20:0];


  assign Compare_To_Constant_out1 = Extract_Bits_out1 < 21'b000000000000000001000;


  SYSTEM_ip_src_pulse_10mks1 u_pulse_10mks1 (.clk(clk),
                                             .reset_x(reset_x),
                                             .PULSE_LEN(Constant2_out1),  // uint16
                                             .trigger(AND_out1),
                                             .value(valuedeadOutdeadOut),  // uint16
                                             .valid(valid)
                                             );
  assign NOT_out1 =  ~ valid;


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay9_process
      if (reset_x == 1'b1) begin
        Unit_Delay9_out1 <= 1'b0;
      end
      else begin
        Unit_Delay9_out1 <= NOT_out1;
      end
    end


  assign AND_out1 = Unit_Delay9_out1 & Compare_To_Constant_out1;


  SYSTEM_ip_src_pulse_10mks u_pulse_10mks (.clk(clk),
                                           .reset_x(reset_x),
                                           .PULSE_LEN(Constant_out1),  // uint16
                                           .trigger(AND_out1),
                                           .value(valuedeadOutdeadOut_1),  // uint16
                                           .valid(valid_1)
                                           );
  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay4_process
      if (reset_x == 1'b1) begin
        Unit_Delay4_out1 <= 1'b0;
      end
      else begin
        Unit_Delay4_out1 <= valid_1;
      end
    end


  assign tstamp_strobe = Unit_Delay4_out1;

  assign TS_REG_out1 = 64'h0000000000000000;



  assign time_stamp_tick = TS_REG_out1;

endmodule  // SYSTEM_ip_src_time_stamp_engine

