// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\tb_SYSTEM\SYSTEM_ip_src_spi_sm_block.v
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SYSTEM_ip_src_spi_sm_block
// Source Path: tb_SYSTEM/SYSTEM/AD9545CC/spi_sm
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SYSTEM_ip_src_spi_sm_block
          (clk,
           reset_x,
           data_in,
           MISO,
           start,
           nCS,
           MOSI,
           data_out,
           SCK,
           stop);

  parameter [7:0] bit_len = 24;  // uint8
  parameter [7:0] clk_len = 8;  // uint8
  // Default encoded enumeration values for type state_type_is_spi_sm1
  parameter state_type_is_spi_sm1_IN_IDLE = 2'd0, state_type_is_spi_sm1_IN_ONE_BIT = 2'd1, state_type_is_spi_sm1_IN_RESET = 2'd2, state_type_is_spi_sm1_IN_WAIT = 2'd3;

  input   clk;
  input   reset_x;
  input   [23:0] data_in;  // ufix24
  input   MISO;  // ufix1
  input   start;
  output  nCS;  // ufix1
  output  MOSI;  // ufix1
  output  [23:0] data_out;  // ufix24
  output  SCK;  // ufix1
  output  stop;


  reg [1:0] is_spi_sm;  // uint8
  reg [7:0] cnt_clk;  // uint8
  reg [7:0] cnt_bit;  // uint8
  reg [23:0] din;  // ufix24
  reg [23:0] dout;  // ufix24
  reg [3:0] temporalCounter_i1;  // ufix4
  reg  nCS_reg;  // ufix1
  reg  MOSI_reg;  // ufix1
  reg [23:0] data_out_reg;  // ufix24
  reg  SCK_reg;  // ufix1
  reg  stop_reg;
  reg [1:0] is_spi_sm_next;  // enum type state_type_is_spi_sm1 (4 enums)
  reg [7:0] cnt_clk_next;  // uint8
  reg [7:0] cnt_bit_next;  // uint8
  reg [23:0] din_next;  // ufix24
  reg [23:0] dout_next;  // ufix24
  reg [3:0] temporalCounter_i1_next;  // ufix4
  reg  nCS_reg_next;  // ufix1
  reg  MOSI_reg_next;  // ufix1
  reg [23:0] data_out_reg_next;  // ufix24
  reg  SCK_reg_next;  // ufix1
  reg  stop_reg_next;
  reg  c;  // ufix1
  reg [7:0] bit_idx;  // uint8
  reg [23:0] mask;  // ufix24
  reg  c_0;  // ufix1
  reg [7:0] bit_idx_0;  // uint8
  reg  c_1;  // ufix1
  reg [7:0] bit_idx_1;  // uint8
  reg [23:0] mask_0;  // ufix24
  reg [23:0] mask_1;  // ufix24
  reg [7:0] cnt_clk_temp;  // uint8
  reg [3:0] temporalCounter_i1_temp;  // ufix4
  reg [7:0] add_temp;  // ufix8
  reg signed [31:0] t_0;  // int32
  reg [7:0] sub_temp;  // ufix8
  reg signed [31:0] t_1;  // int32
  reg [7:0] sub_temp_0;  // ufix8
  reg signed [31:0] t_2;  // int32


  always @(posedge clk or posedge reset_x)
    begin : spi_sm_process
      if (reset_x == 1'b1) begin
        temporalCounter_i1 <= 4'b0000;
        stop_reg <= 1'b0;
        //Entry: SYSTEM/AD9545CC/spi_sm
        //Entry Internal: SYSTEM/AD9545CC/spi_sm
        //Transition
        is_spi_sm <= state_type_is_spi_sm1_IN_RESET;
        //Entry 'RESET'
        nCS_reg <= 1'b1;
        SCK_reg <= 1'b1;
        MOSI_reg <= 1'b0;
        cnt_clk <= 8'd0;
        cnt_bit <= 8'd0;
        dout <= 24'b000000000000000000000000;
        din <= 24'b000000000000000000000000;
        data_out_reg <= 24'b000000000000000000000000;
      end
      else begin
        is_spi_sm <= is_spi_sm_next;
        cnt_clk <= cnt_clk_next;
        cnt_bit <= cnt_bit_next;
        din <= din_next;
        dout <= dout_next;
        temporalCounter_i1 <= temporalCounter_i1_next;
        nCS_reg <= nCS_reg_next;
        MOSI_reg <= MOSI_reg_next;
        data_out_reg <= data_out_reg_next;
        SCK_reg <= SCK_reg_next;
        stop_reg <= stop_reg_next;
      end
    end

  always @(MISO, MOSI_reg, SCK_reg, cnt_bit, cnt_clk, data_in, data_out_reg, din, dout,
       is_spi_sm, nCS_reg, start, stop_reg, temporalCounter_i1) begin
    c = 1'b0;
    bit_idx = 8'd0;
    mask = 24'b000000000000000000000000;
    c_0 = 1'b0;
    c_1 = 1'b0;
    bit_idx_0 = 8'd0;
    bit_idx_1 = 8'd0;
    mask_1 = 24'b000000000000000000000000;
    add_temp = 8'b00000000;
    sub_temp = 8'b00000000;
    sub_temp_0 = 8'b00000000;
    t_0 = 32'sd0;
    t_1 = 32'sd0;
    t_2 = 32'sd0;
    cnt_clk_temp = cnt_clk + 8'b00000001;
    cnt_bit_next = cnt_bit;
    din_next = din;
    mask_0 = dout;
    temporalCounter_i1_temp = temporalCounter_i1;
    nCS_reg_next = nCS_reg;
    MOSI_reg_next = MOSI_reg;
    data_out_reg_next = data_out_reg;
    SCK_reg_next = SCK_reg;
    stop_reg_next = stop_reg;
    is_spi_sm_next = is_spi_sm;
    //Gateway: SYSTEM/AD9545CC/spi_sm
    if (temporalCounter_i1 < 4'b1111) begin
      temporalCounter_i1_temp = temporalCounter_i1 + 4'b0001;
    end
    //During: SYSTEM/AD9545CC/spi_sm
    case ( is_spi_sm)
      state_type_is_spi_sm1_IN_IDLE :
        begin
          //During 'IDLE'
          if (start) begin
            //Transition
            nCS_reg_next = 1'b0;
            din_next = data_in;
            is_spi_sm_next = state_type_is_spi_sm1_IN_ONE_BIT;
            //Entry 'ONE_BIT'
            cnt_clk_temp = cnt_clk;
            if ((cnt_bit >= 8'b00000001) && (cnt_bit <= 8'b00011000)) begin
              bit_idx_0 = cnt_bit - 8'd1;
              c_0 = data_in[bit_idx_0];
            end
            else begin
              c_0 = 1'b0;
            end
            if (c_0 == 1'b1) begin
              MOSI_reg_next = 1'b1;
            end
            else begin
              MOSI_reg_next = 1'b0;
            end
            if ((cnt_clk - 8'b00000001) > 8'b00000100) begin
              SCK_reg_next = 1'b0;
            end
            else begin
              SCK_reg_next = 1'b1;
            end
            sub_temp_0 = cnt_bit - 8'b00000001;
            t_2 = {24'b0, sub_temp_0};
            mask_0 = 24'b000000000000000000000001 <<< t_2;
            if ( ! (MISO != 1'b0)) begin
              mask_0 = 24'b000000000000000000000000;
            end
          end
          else begin
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd9;
            cnt_bit_next = bit_len;
            din_next = data_in;
            data_out_reg_next = dout;
          end
        end
      state_type_is_spi_sm1_IN_ONE_BIT :
        begin
          //During 'ONE_BIT'
          if (cnt_clk == 8'b00000000) begin
            //Transition
            cnt_clk_temp = 8'd9;
            cnt_bit_next = cnt_bit - 8'b00000001;
            if ((cnt_bit - 8'b00000001) == 8'b00000000) begin
              //Transition
              nCS_reg_next = 1'b1;
              data_out_reg_next = dout;
              is_spi_sm_next = state_type_is_spi_sm1_IN_WAIT;
              temporalCounter_i1_temp = 4'b0000;
              //Entry 'WAIT'
              stop_reg_next = 1'b1;
            end
            else begin
              //Transition
              is_spi_sm_next = state_type_is_spi_sm1_IN_ONE_BIT;
              //Entry 'ONE_BIT'
              cnt_clk_temp = clk_len;
              if (((cnt_bit - 8'b00000001) >= 8'b00000001) && ((cnt_bit - 8'b00000001) <= 8'b00011000)) begin
                bit_idx_1 = (cnt_bit - 8'b00000001) - 8'b00000001;
                c_1 = din[bit_idx_1];
              end
              else begin
                c_1 = 1'b0;
              end
              if (c_1 == 1'b1) begin
                MOSI_reg_next = 1'b1;
              end
              else begin
                MOSI_reg_next = 1'b0;
              end
              SCK_reg_next = 1'b0;
              add_temp = cnt_bit + 8'd254;
              t_0 = {24'b0, add_temp};
              mask_1 = 24'b000000000000000000000001 <<< t_0;
              if (MISO != 1'b0) begin
                mask_0 = dout | mask_1;
              end
              else begin
                mask_0 = dout & ( ~ mask_1);
              end
            end
          end
          else begin
            cnt_clk_temp = cnt_clk;
            if ((cnt_bit >= 8'b00000001) && (cnt_bit <= 8'b00011000)) begin
              bit_idx = cnt_bit - 8'd1;
              c = din[bit_idx];
            end
            else begin
              c = 1'b0;
            end
            if (c == 1'b1) begin
              MOSI_reg_next = 1'b1;
            end
            else begin
              MOSI_reg_next = 1'b0;
            end
            if ((cnt_clk - 8'b00000001) > 8'b00000100) begin
              SCK_reg_next = 1'b0;
            end
            else begin
              SCK_reg_next = 1'b1;
            end
            sub_temp = cnt_bit - 8'b00000001;
            t_1 = {24'b0, sub_temp};
            mask = 24'b000000000000000000000001 <<< t_1;
            if (MISO != 1'b0) begin
              mask_0 = dout | mask;
            end
            else begin
              mask_0 = dout & ( ~ mask);
            end
          end
        end
      state_type_is_spi_sm1_IN_RESET :
        begin
          //During 'RESET'
          //Transition
          is_spi_sm_next = state_type_is_spi_sm1_IN_IDLE;
          //Entry 'IDLE'
          nCS_reg_next = 1'b1;
          SCK_reg_next = 1'b1;
          MOSI_reg_next = 1'b0;
          cnt_clk_temp = 8'd9;
          cnt_bit_next = bit_len;
          din_next = data_in;
          data_out_reg_next = dout;
        end
      default :
        begin
          //case IN_WAIT:
          //During 'WAIT'
          if (temporalCounter_i1_temp >= 4'b1000) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm1_IN_IDLE;
            //Entry 'IDLE'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd9;
            cnt_bit_next = bit_len;
            din_next = data_in;
            data_out_reg_next = dout;
          end
          else begin
            stop_reg_next = 1'b0;
          end
        end
    endcase
    cnt_clk_next = cnt_clk_temp - 8'b00000001;
    dout_next = mask_0;
    temporalCounter_i1_next = temporalCounter_i1_temp;
  end

  assign nCS = nCS_reg_next;
  assign MOSI = MOSI_reg_next;
  assign data_out = data_out_reg_next;
  assign SCK = SCK_reg_next;
  assign stop = stop_reg_next;


endmodule  // SYSTEM_ip_src_spi_sm_block

