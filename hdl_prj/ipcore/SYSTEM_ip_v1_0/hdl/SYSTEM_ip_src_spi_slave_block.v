// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\tb_SYSTEM\SYSTEM_ip_src_spi_slave_block.v
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SYSTEM_ip_src_spi_slave_block
// Source Path: tb_SYSTEM/SYSTEM/spi2axil/spi_slave
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SYSTEM_ip_src_spi_slave_block
          (clk,
           reset_x,
           nCS,
           MOSI,
           SCK,
           rdata,
           tdata,
           MISO,
           wvalid,
           rvalid,
           wdata,
           waddr,
           raddr,
           cbit,
           cword,
           drecvd,
           odata);

  parameter [7:0] nbit = 32;  // uint8
  // Default encoded enumeration values for type state_type_is_spi_slave1
  parameter state_type_is_spi_slave1_IN_BIT_LATCH = 3'd0, state_type_is_spi_slave1_IN_CLK_HIGH_WAIT = 3'd1, state_type_is_spi_slave1_IN_CLK_LOW_WAIT = 3'd2, state_type_is_spi_slave1_IN_IDLE = 3'd3, state_type_is_spi_slave1_IN_RESET = 3'd4;

  input   clk;
  input   reset_x;
  input   nCS;
  input   MOSI;
  input   SCK;
  input   [31:0] rdata;  // uint32
  input   [31:0] tdata;  // uint32
  output  MISO;
  output  wvalid;
  output  rvalid;
  output  [31:0] wdata;  // uint32
  output  [31:0] waddr;  // uint32
  output  [31:0] raddr;  // uint32
  output  [7:0] cbit;  // uint8
  output  [7:0] cword;  // uint8
  output  [31:0] drecvd;  // uint32
  output  [31:0] odata;  // uint32


  reg [2:0] is_spi_slave;  // uint8
  reg  next_data_write;
  reg  next_data_read;
  reg  next_data_test;
  wire [7:0] cbitdeadOut;  // uint8
  wire [7:0] cworddeadOut;  // uint8
  wire [31:0] drecvddeadOut;  // uint32
  reg  MISO_reg;
  reg  wvalid_reg;
  reg  rvalid_reg;
  reg [31:0] wdata_reg;  // uint32
  reg [31:0] waddr_reg;  // uint32
  reg [31:0] raddr_reg;  // uint32
  reg [7:0] cbit_reg;  // uint8
  reg [7:0] cword_reg;  // uint8
  reg [31:0] drecvd_reg;  // uint32
  reg [31:0] odata_reg;  // uint32
  reg [2:0] is_spi_slave_next;  // enum type state_type_is_spi_slave1 (5 enums)
  reg  next_data_write_next;
  reg  next_data_read_next;
  reg  next_data_test_next;
  reg  MISO_reg_next;
  reg  wvalid_reg_next;
  reg  rvalid_reg_next;
  reg [31:0] wdata_reg_next;  // uint32
  reg [31:0] waddr_reg_next;  // uint32
  reg [31:0] raddr_reg_next;  // uint32
  reg [7:0] cbit_reg_next;  // uint8
  reg [7:0] cword_reg_next;  // uint8
  reg [31:0] drecvd_reg_next;  // uint32
  reg [31:0] odata_reg_next;  // uint32
  reg signed [31:0] oper;  // uint32
  reg [31:0] c;  // uint32
  reg [7:0] bm1;  // uint8
  reg [7:0] bm1_0;  // uint8
  reg [7:0] bm1_1;  // uint8
  reg [31:0] mask;  // uint32
  reg  guard1;
  reg  next_data_read_temp;
  reg  next_data_test_temp;
  reg [7:0] cword_reg_temp;  // uint8
  reg [8:0] add_temp;  // ufix9
  reg [8:0] add_temp_0;  // ufix9
  reg [7:0] sub_cast;  // uint8
  reg [8:0] add_temp_1;  // ufix9
  reg [32:0] add_temp_2;  // ufix33
  reg [8:0] add_temp_3;  // ufix9
  reg [7:0] sub_cast_0;  // uint8
  reg [7:0] sub_temp;  // ufix8
  reg signed [31:0] t_0;  // int32
  reg [31:0] t_1;  // ufix32
  reg [8:0] t_2;  // ufix9
  reg [8:0] t_3;  // ufix9
  reg [8:0] t_4;  // ufix9
  reg [32:0] t_5;  // ufix33
  reg [8:0] t_6;  // ufix9


  always @(posedge clk or posedge reset_x)
    begin : spi_slave_process
      if (reset_x == 1'b1) begin
        //Entry: SYSTEM/spi2axil/spi_slave
        //Entry Internal: SYSTEM/spi2axil/spi_slave
        //Transition
        is_spi_slave <= state_type_is_spi_slave1_IN_RESET;
        //Entry 'RESET'
        MISO_reg <= 1'b0;
        cbit_reg <= 8'd0;
        cword_reg <= 8'd0;
        drecvd_reg <= 32'd0;
        next_data_write <= 1'b0;
        next_data_read <= 1'b0;
        next_data_test <= 1'b0;
        wvalid_reg <= 1'b0;
        waddr_reg <= 32'd0;
        wdata_reg <= 32'd0;
        rvalid_reg <= 1'b0;
        raddr_reg <= 32'd0;
        odata_reg <= 32'd0;
      end
      else begin
        is_spi_slave <= is_spi_slave_next;
        next_data_write <= next_data_write_next;
        next_data_read <= next_data_read_next;
        next_data_test <= next_data_test_next;
        MISO_reg <= MISO_reg_next;
        wvalid_reg <= wvalid_reg_next;
        rvalid_reg <= rvalid_reg_next;
        wdata_reg <= wdata_reg_next;
        waddr_reg <= waddr_reg_next;
        raddr_reg <= raddr_reg_next;
        cbit_reg <= cbit_reg_next;
        cword_reg <= cword_reg_next;
        drecvd_reg <= drecvd_reg_next;
        odata_reg <= odata_reg_next;
      end
    end

  always @(MISO_reg, MOSI, SCK, cbit_reg, cword_reg, drecvd_reg, is_spi_slave, nCS,
       next_data_read, next_data_test, next_data_write, odata_reg, raddr_reg,
       rdata, rvalid_reg, tdata, waddr_reg, wdata_reg, wvalid_reg) begin
    bm1 = 8'd0;
    bm1_0 = 8'd0;
    mask = 32'd0;
    add_temp = 9'b000000000;
    add_temp_0 = 9'b000000000;
    add_temp_1 = 9'b000000000;
    add_temp_2 = 33'h000000000;
    add_temp_3 = 9'b000000000;
    sub_temp = 8'b00000000;
    t_1 = 32'b00000000000000000000000000000000;
    sub_cast = 8'd0;
    sub_cast_0 = 8'd0;
    t_0 = 32'sd0;
    t_2 = 9'b000000000;
    t_3 = 9'b000000000;
    t_4 = 9'b000000000;
    t_5 = 33'h000000000;
    t_6 = 9'b000000000;
    bm1_1 = cbit_reg;
    cword_reg_temp = cword_reg;
    c = drecvd_reg;
    next_data_read_temp = next_data_read;
    next_data_test_temp = next_data_test;
    MISO_reg_next = MISO_reg;
    wvalid_reg_next = wvalid_reg;
    rvalid_reg_next = rvalid_reg;
    wdata_reg_next = wdata_reg;
    waddr_reg_next = waddr_reg;
    raddr_reg_next = raddr_reg;
    odata_reg_next = odata_reg;
    is_spi_slave_next = is_spi_slave;
    next_data_write_next = next_data_write;
    //Gateway: SYSTEM/spi2axil/spi_slave
    //During: SYSTEM/spi2axil/spi_slave
    guard1 = 1'b0;
    case ( is_spi_slave)
      state_type_is_spi_slave1_IN_BIT_LATCH :
        begin
          //During 'BIT_LATCH'
          if (nCS) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_IDLE;
            //Entry 'IDLE'
            bm1_1 = 8'd0;
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            next_data_write_next = 1'b0;
            next_data_read_temp = 1'b0;
            next_data_test_temp = 1'b0;
            cword_reg_temp = 8'd0;
            MISO_reg_next = 1'b0;
            c = 32'd0;
          end
          else if ( ! SCK) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_CLK_HIGH_WAIT;
            //Entry 'CLK_HIGH_WAIT'
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
          end
          else begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_CLK_LOW_WAIT;
            //Entry 'CLK_LOW_WAIT'
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
          end
        end
      state_type_is_spi_slave1_IN_CLK_HIGH_WAIT :
        begin
          //During 'CLK_HIGH_WAIT'
          if (nCS) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_IDLE;
            //Entry 'IDLE'
            bm1_1 = 8'd0;
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            next_data_write_next = 1'b0;
            next_data_read_temp = 1'b0;
            next_data_test_temp = 1'b0;
            cword_reg_temp = 8'd0;
            MISO_reg_next = 1'b0;
            c = 32'd0;
          end
          else if (SCK) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_BIT_LATCH;
            //Entry 'BIT_LATCH'
            t_2 = {1'b0, cbit_reg};
            add_temp = t_2 + 9'b000000001;
            if (add_temp[8] != 1'b0) begin
              bm1_1 = 8'b11111111;
            end
            else begin
              bm1_1 = add_temp[7:0];
            end
            //
            sub_temp = bm1_1 - 8'b00000001;
            t_0 = {24'b0, sub_temp};
            mask = 32'b00000000000000000000000000000001 <<< t_0;
            if (MOSI) begin
              c = drecvd_reg | mask;
            end
            else begin
              c = drecvd_reg & ( ~ mask);
            end
            t_1 = c & 32'b00000000000000000000000000000011;
            oper = t_1;
            //
            if (bm1_1 == nbit) begin
              if ((oper == 32'sb00000000000000000000000000000000) && (cword_reg == 8'b00000000)) begin
                waddr_reg_next = c & 32'd4294967292;
                next_data_write_next = 1'b1;
              end
              else if ((oper == 32'sb00000000000000000000000000000011) && (cword_reg == 8'b00000000)) begin
                rvalid_reg_next = 1'b1;
                raddr_reg_next = c & 32'd4294967292;
                next_data_read_temp = 1'b1;
              end
              else if ((oper == 32'sb00000000000000000000000000000010) && (cword_reg == 8'b00000000)) begin
                next_data_test_temp = 1'b1;
                odata_reg_next = c;
              end
              else if (next_data_write) begin
                wvalid_reg_next = 1'b1;
                wdata_reg_next = c;
                if (cword_reg > 8'b00000001) begin
                  t_5 = {1'b0, waddr_reg};
                  add_temp_2 = t_5 + 33'h000000004;
                  if (add_temp_2[32] != 1'b0) begin
                    waddr_reg_next = 32'b11111111111111111111111111111111;
                  end
                  else begin
                    waddr_reg_next = add_temp_2[31:0];
                  end
                end
              end
              t_4 = {1'b0, cword_reg};
              add_temp_1 = t_4 + 9'b000000001;
              if (add_temp_1[8] != 1'b0) begin
                cword_reg_temp = 8'b11111111;
              end
              else begin
                cword_reg_temp = add_temp_1[7:0];
              end
            end
            // first 1M axi space without dummy word
            if (((bm1_1 == 8'b00010100) && (oper == 32'sb00000000000000000000000000000001)) && (cword_reg_temp == 8'b00000000)) begin
              rvalid_reg_next = 1'b1;
              raddr_reg_next = c & 32'b00000000000011111111111111111100;
              next_data_read_temp = 1'b1;
            end
            //
            if (bm1_1 == nbit) begin
              bm1_1 = 8'd0;
            end
            //
            if (next_data_read_temp && (cword_reg_temp > 8'b00000000)) begin
              t_6 = {1'b0, bm1_1};
              add_temp_3 = t_6 + 9'b000000001;
              if (add_temp_3[8] != 1'b0) begin
                sub_cast_0 = 8'b11111111;
              end
              else begin
                sub_cast_0 = add_temp_3[7:0];
              end
              bm1 = sub_cast_0 - 8'b00000001;
              if (rdata[bm1] != 1'b0) begin
                MISO_reg_next = 1'b1;
              end
              else begin
                guard1 = 1'b1;
              end
            end
            else begin
              guard1 = 1'b1;
            end
          end
          else begin
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
          end
        end
      state_type_is_spi_slave1_IN_CLK_LOW_WAIT :
        begin
          //During 'CLK_LOW_WAIT'
          if (nCS) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_IDLE;
            //Entry 'IDLE'
            bm1_1 = 8'd0;
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            next_data_write_next = 1'b0;
            next_data_read_temp = 1'b0;
            next_data_test_temp = 1'b0;
            cword_reg_temp = 8'd0;
            MISO_reg_next = 1'b0;
            c = 32'd0;
          end
          else if ( ! SCK) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_CLK_HIGH_WAIT;
            //Entry 'CLK_HIGH_WAIT'
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
          end
          else begin
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
          end
        end
      state_type_is_spi_slave1_IN_IDLE :
        begin
          //During 'IDLE'
          if ( ! nCS) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave1_IN_CLK_HIGH_WAIT;
            //Entry 'CLK_HIGH_WAIT'
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
          end
          else begin
            bm1_1 = 8'd0;
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            next_data_write_next = 1'b0;
            next_data_read_temp = 1'b0;
            next_data_test_temp = 1'b0;
            cword_reg_temp = 8'd0;
            MISO_reg_next = 1'b0;
            c = 32'd0;
          end
        end
      default :
        begin
          //case IN_RESET:
          //During 'RESET'
          //Transition
          is_spi_slave_next = state_type_is_spi_slave1_IN_IDLE;
          //Entry 'IDLE'
          bm1_1 = 8'd0;
          wvalid_reg_next = 1'b0;
          rvalid_reg_next = 1'b0;
          next_data_write_next = 1'b0;
          next_data_read_temp = 1'b0;
          next_data_test_temp = 1'b0;
          cword_reg_temp = 8'd0;
          MISO_reg_next = 1'b0;
          c = 32'd0;
        end
    endcase
    if (guard1) begin
      if (next_data_test_temp) begin
        t_3 = {1'b0, bm1_1};
        add_temp_0 = t_3 + 9'b000000001;
        if (add_temp_0[8] != 1'b0) begin
          sub_cast = 8'b11111111;
        end
        else begin
          sub_cast = add_temp_0[7:0];
        end
        bm1_0 = sub_cast - 8'b00000001;
        MISO_reg_next = tdata[bm1_0] != 1'b0;
      end
      else begin
        MISO_reg_next = 1'b0;
      end
    end
    next_data_read_next = next_data_read_temp;
    next_data_test_next = next_data_test_temp;
    cbit_reg_next = bm1_1;
    cword_reg_next = cword_reg_temp;
    drecvd_reg_next = c;
  end

  assign MISO = MISO_reg_next;
  assign wvalid = wvalid_reg_next;
  assign rvalid = rvalid_reg_next;
  assign wdata = wdata_reg_next;
  assign waddr = waddr_reg_next;
  assign raddr = raddr_reg_next;
  assign cbitdeadOut = cbit_reg_next;
  assign cworddeadOut = cword_reg_next;
  assign drecvddeadOut = drecvd_reg_next;
  assign odata = odata_reg_next;


  assign cbit = 8'b00000000;



  assign cword = 8'b00000000;



  assign drecvd = 32'b00000000000000000000000000000000;



endmodule  // SYSTEM_ip_src_spi_slave_block

