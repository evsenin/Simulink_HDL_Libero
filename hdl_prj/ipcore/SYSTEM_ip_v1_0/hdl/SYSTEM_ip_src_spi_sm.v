// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\tb_SYSTEM\SYSTEM_ip_src_spi_sm.v
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SYSTEM_ip_src_spi_sm
// Source Path: tb_SYSTEM/SYSTEM/AD7173-8-ADC_0/spi_sm
// Hierarchy Level: 2
// 
// Dealy 500us before next command
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SYSTEM_ip_src_spi_sm
          (clk,
           reset_x,
           data_in,
           MISO,
           start,
           rst,
           start_cont_read,
           nCS,
           MOSI,
           SCK,
           stop,
           cont_read_enabled,
           dread_push,
           dread_out,
           dout,
           dread_wait);

  parameter [23:0] b_AD7173_8_IFMODE = 131264;  // ufix24
  // Default encoded enumeration values for type state_type_is_spi_sm
  parameter state_type_is_spi_sm_IN_CONT_READ_GET = 4'd0, state_type_is_spi_sm_IN_CONT_READ_INIT = 4'd1, state_type_is_spi_sm_IN_CONT_READ_WAIT_nRDY = 4'd2, state_type_is_spi_sm_IN_IDLE = 4'd3, state_type_is_spi_sm_IN_ONE_TRANSACTION = 4'd4, state_type_is_spi_sm_IN_RESET = 4'd5, state_type_is_spi_sm_IN_SW_RESET = 4'd6, state_type_is_spi_sm_IN_WAIT = 4'd7, state_type_is_spi_sm_IN_WAIT_READY = 4'd8, state_type_is_spi_sm_IN_WAIT_nRDY = 4'd9;

  input   clk;
  input   reset_x;
  input   [23:0] data_in;  // ufix24
  input   MISO;  // ufix1
  input   start;
  input   rst;
  input   start_cont_read;
  output  nCS;  // ufix1
  output  MOSI;  // ufix1
  output  SCK;  // ufix1
  output  stop;
  output  cont_read_enabled;
  output  dread_push;
  output  [31:0] dread_out;  // uint32
  output  [23:0] dout;  // ufix24
  output  dread_wait;


  reg [3:0] is_spi_sm;  // uint8
  reg [7:0] cnt_clk;  // uint8
  reg [7:0] cnt_bit;  // uint8
  reg [23:0] din;  // ufix24
  wire dread_waitdeadOut;
  reg [31:0] temporalCounter_i1;  // ufix32
  reg  nCS_reg;  // ufix1
  reg  MOSI_reg;  // ufix1
  reg  SCK_reg;  // ufix1
  reg  stop_reg;
  reg  cont_read_enabled_reg;
  reg  dread_push_reg;
  reg [31:0] dread_out_reg;  // ufix32
  reg [23:0] dout_reg;  // ufix24
  reg  dread_wait_reg;
  reg [3:0] is_spi_sm_next;  // enum type state_type_is_spi_sm (10 enums)
  reg [7:0] cnt_clk_next;  // uint8
  reg [7:0] cnt_bit_next;  // uint8
  reg [23:0] din_next;  // ufix24
  reg [31:0] temporalCounter_i1_next;  // ufix32
  reg  nCS_reg_next;  // ufix1
  reg  MOSI_reg_next;  // ufix1
  reg  SCK_reg_next;  // ufix1
  reg  stop_reg_next;
  reg  cont_read_enabled_reg_next;
  reg  dread_push_reg_next;
  reg [31:0] dread_out_reg_next;  // ufix32
  reg [23:0] dout_reg_next;  // ufix24
  reg  dread_wait_reg_next;
  reg  sf_internal_predicateOutput;
  reg  sf_internal_predicateOutput_0;
  reg  c;  // ufix1
  reg [7:0] bit_idx;  // uint8
  reg  c_0;  // ufix1
  reg [7:0] bit_idx_0;  // uint8
  reg [31:0] mask;  // ufix32
  reg [23:0] mask_0;  // ufix24
  reg [7:0] cnt_clk_temp;  // uint8
  reg [7:0] cnt_bit_temp;  // uint8
  reg [31:0] temporalCounter_i1_temp;  // ufix32
  reg [7:0] sub_temp;  // ufix8
  reg signed [31:0] t_0;  // int32
  reg [7:0] sub_temp_0;  // ufix8
  reg signed [31:0] t_1;  // int32


  always @(posedge clk or posedge reset_x)
    begin : spi_sm_process
      if (reset_x == 1'b1) begin
        stop_reg <= 1'b0;
        //Entry: SYSTEM/AD7173-8-ADC_0/spi_sm
        //Entry Internal: SYSTEM/AD7173-8-ADC_0/spi_sm
        //Transition
        is_spi_sm <= state_type_is_spi_sm_IN_RESET;
        temporalCounter_i1 <= 32'b00000000000000000000000000000000;
        //Entry 'RESET'
        nCS_reg <= 1'b1;
        SCK_reg <= 1'b1;
        MOSI_reg <= 1'b0;
        cnt_clk <= 8'd0;
        cnt_bit <= 8'd0;
        dout_reg <= 24'b000000000000000000000000;
        din <= 24'b000000000000000000000000;
        cont_read_enabled_reg <= 1'b0;
        dread_out_reg <= 32'b00000000000000000000000000000000;
        dread_push_reg <= 1'b0;
        dread_wait_reg <= 1'b1;
      end
      else begin
        is_spi_sm <= is_spi_sm_next;
        cnt_clk <= cnt_clk_next;
        cnt_bit <= cnt_bit_next;
        din <= din_next;
        temporalCounter_i1 <= temporalCounter_i1_next;
        nCS_reg <= nCS_reg_next;
        MOSI_reg <= MOSI_reg_next;
        SCK_reg <= SCK_reg_next;
        stop_reg <= stop_reg_next;
        cont_read_enabled_reg <= cont_read_enabled_reg_next;
        dread_push_reg <= dread_push_reg_next;
        dread_out_reg <= dread_out_reg_next;
        dout_reg <= dout_reg_next;
        dread_wait_reg <= dread_wait_reg_next;
      end
    end

  always @(MISO, MOSI_reg, SCK_reg, cnt_bit, cnt_clk, cont_read_enabled_reg, data_in, din,
       dout_reg, dread_out_reg, dread_push_reg, dread_wait_reg, is_spi_sm,
       nCS_reg, rst, start, start_cont_read, stop_reg, temporalCounter_i1) begin
    mask_0 = 24'b000000000000000000000000;
    mask = 32'b00000000000000000000000000000000;
    bit_idx_0 = 8'd0;
    bit_idx = 8'd0;
    c_0 = 1'b0;
    c = 1'b0;
    sf_internal_predicateOutput_0 = 1'b0;
    sf_internal_predicateOutput = 1'b0;
    sub_temp = 8'b00000000;
    sub_temp_0 = 8'b00000000;
    t_0 = 32'sd0;
    t_1 = 32'sd0;
    cnt_clk_temp = cnt_clk + 8'b00000001;
    cnt_bit_temp = cnt_bit + 8'b00000001;
    din_next = din;
    temporalCounter_i1_temp = temporalCounter_i1;
    nCS_reg_next = nCS_reg;
    MOSI_reg_next = MOSI_reg;
    SCK_reg_next = SCK_reg;
    stop_reg_next = stop_reg;
    cont_read_enabled_reg_next = cont_read_enabled_reg;
    dread_push_reg_next = dread_push_reg;
    dread_out_reg_next = dread_out_reg;
    dout_reg_next = dout_reg;
    dread_wait_reg_next = dread_wait_reg;
    is_spi_sm_next = is_spi_sm;
    //Gateway: SYSTEM/AD7173-8-ADC_0/spi_sm
    if (temporalCounter_i1 < 32'd4294967295) begin
      temporalCounter_i1_temp = temporalCounter_i1 + 32'b00000000000000000000000000000001;
    end
    //During: SYSTEM/AD7173-8-ADC_0/spi_sm
    case ( is_spi_sm)
      state_type_is_spi_sm_IN_CONT_READ_GET :
        begin
          //During 'CONT_READ_GET'
          if (dread_push_reg) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_WAIT_nRDY;
            temporalCounter_i1_temp = 32'b00000000000000000000000000000000;
            //Entry 'WAIT_nRDY'
            dread_push_reg_next = 1'b0;
          end
          else begin
            cnt_clk_temp = cnt_clk;
            if ((cnt_clk - 8'b00000001) > 8'b00000100) begin
              SCK_reg_next = 1'b0;
            end
            else begin
              SCK_reg_next = 1'b1;
            end
            if ((cnt_clk - 8'b00000001) == 8'b00000100) begin
              sub_temp_0 = cnt_bit - 8'b00000001;
              t_1 = {24'b0, sub_temp_0};
              mask = 32'b00000000000000000000000000000001 <<< t_1;
              if (MISO != 1'b0) begin
                dread_out_reg_next = dread_out_reg | mask;
              end
              else begin
                dread_out_reg_next = dread_out_reg & ( ~ mask);
              end
            end
            if ((cnt_clk - 8'b00000001) == 8'b00000000) begin
              cnt_clk_temp = 8'd9;
              cnt_bit_temp = cnt_bit;
            end
            if ((cnt_bit_temp - 8'b00000001) == 8'b00000000) begin
              dread_push_reg_next = 1'b1;
            end
          end
        end
      state_type_is_spi_sm_IN_CONT_READ_INIT :
        begin
          //During 'CONT_READ_INIT'
          if (cnt_bit == 8'b00000000) begin
            //Transition
            //Exit 'CONT_READ_INIT'
            cont_read_enabled_reg_next = 1'b1;
            is_spi_sm_next = state_type_is_spi_sm_IN_CONT_READ_WAIT_nRDY;
            //Entry 'CONT_READ_WAIT_nRDY'
            nCS_reg_next = 1'b0;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd33;
            dread_push_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
          else begin
            cnt_clk_temp = cnt_clk;
            if ((cnt_bit >= 8'b00000001) && (cnt_bit <= 8'b00011000)) begin
              bit_idx = cnt_bit - 8'd1;
              c = din[bit_idx];
            end
            else begin
              c = 1'b0;
            end
            if (c == 1'b1) begin
              MOSI_reg_next = 1'b1;
            end
            else begin
              MOSI_reg_next = 1'b0;
            end
            if ((cnt_clk - 8'b00000001) > 8'b00000100) begin
              SCK_reg_next = 1'b0;
            end
            else begin
              SCK_reg_next = 1'b1;
            end
            if ((cnt_clk - 8'b00000001) == 8'b00000000) begin
              cnt_clk_temp = 8'd9;
              cnt_bit_temp = cnt_bit;
            end
          end
        end
      state_type_is_spi_sm_IN_CONT_READ_WAIT_nRDY :
        begin
          //During 'CONT_READ_WAIT_nRDY'
          if (rst) begin
            //Transition
            //Exit 'CONT_READ_WAIT_nRDY'
            is_spi_sm_next = state_type_is_spi_sm_IN_RESET;
            temporalCounter_i1_temp = 32'b00000000000000000000000000000000;
            //Entry 'RESET'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd1;
            cnt_bit_temp = 8'd1;
            dout_reg_next = 24'b000000000000000000000000;
            din_next = 24'b000000000000000000000000;
            cont_read_enabled_reg_next = 1'b0;
            dread_out_reg_next = 32'b00000000000000000000000000000000;
            dread_push_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
          else if (MISO == 1'b0) begin
            //Transition
            //Exit 'CONT_READ_WAIT_nRDY'
            dread_wait_reg_next = 1'b0;
            is_spi_sm_next = state_type_is_spi_sm_IN_CONT_READ_GET;
            //Entry 'CONT_READ_GET'
            nCS_reg_next = 1'b0;
            MOSI_reg_next = 1'b0;
            dread_out_reg_next = 32'b00000000000000000000000000000000;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd33;
          end
        end
      state_type_is_spi_sm_IN_IDLE :
        begin
          //During 'IDLE'
          if (rst) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_RESET;
            temporalCounter_i1_temp = 32'b00000000000000000000000000000000;
            //Entry 'RESET'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd1;
            cnt_bit_temp = 8'd1;
            dout_reg_next = 24'b000000000000000000000000;
            din_next = 24'b000000000000000000000000;
            cont_read_enabled_reg_next = 1'b0;
            dread_out_reg_next = 32'b00000000000000000000000000000000;
            dread_push_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
          else if (start) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_ONE_TRANSACTION;
            //Entry 'ONE_TRANSACTION'
            nCS_reg_next = 1'b0;
            dout_reg_next = 24'b000000000000000000000000;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd25;
            din_next = data_in;
          end
          else if (start_cont_read) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_CONT_READ_INIT;
            //Entry 'CONT_READ_INIT'
            nCS_reg_next = 1'b0;
            din_next = b_AD7173_8_IFMODE;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd25;
          end
          else begin
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd25;
            din_next = data_in;
            cont_read_enabled_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
        end
      state_type_is_spi_sm_IN_ONE_TRANSACTION :
        begin
          //During 'ONE_TRANSACTION'
          if (cnt_bit == 8'b00000000) begin
            //Transition
            //Exit 'ONE_TRANSACTION'
            nCS_reg_next = 1'b1;
            is_spi_sm_next = state_type_is_spi_sm_IN_WAIT;
            temporalCounter_i1_temp = 32'b00000000000000000000000000000000;
            //Entry 'WAIT'
            stop_reg_next = 1'b1;
          end
          else begin
            cnt_clk_temp = cnt_clk;
            if ((cnt_bit >= 8'b00000001) && (cnt_bit <= 8'b00011000)) begin
              bit_idx_0 = cnt_bit - 8'd1;
              c_0 = din[bit_idx_0];
            end
            else begin
              c_0 = 1'b0;
            end
            if (c_0 == 1'b1) begin
              MOSI_reg_next = 1'b1;
            end
            else begin
              MOSI_reg_next = 1'b0;
            end
            if ((cnt_clk - 8'b00000001) > 8'b00000100) begin
              SCK_reg_next = 1'b0;
            end
            else begin
              SCK_reg_next = 1'b1;
            end
            sub_temp = cnt_bit - 8'b00000001;
            t_0 = {24'b0, sub_temp};
            mask_0 = 24'b000000000000000000000001 <<< t_0;
            if (MISO != 1'b0) begin
              dout_reg_next = dout_reg | mask_0;
            end
            else begin
              dout_reg_next = dout_reg & ( ~ mask_0);
            end
            if ((cnt_clk - 8'b00000001) == 8'b00000000) begin
              cnt_clk_temp = 8'd9;
              cnt_bit_temp = cnt_bit;
            end
          end
        end
      state_type_is_spi_sm_IN_RESET :
        begin
          //During 'RESET'
          sf_internal_predicateOutput = (temporalCounter_i1_temp >= 32'b00000000000000000000000001000000) &&  ! rst;
          if (sf_internal_predicateOutput) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_SW_RESET;
            //Entry 'SW_RESET'
            nCS_reg_next = 1'b0;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b1;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd65;
          end
          else begin
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd1;
            cnt_bit_temp = 8'd1;
            dout_reg_next = 24'b000000000000000000000000;
            din_next = 24'b000000000000000000000000;
            cont_read_enabled_reg_next = 1'b0;
            dread_out_reg_next = 32'b00000000000000000000000000000000;
            dread_push_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
        end
      state_type_is_spi_sm_IN_SW_RESET :
        begin
          //During 'SW_RESET'
          if (cnt_bit == 8'b00000000) begin
            //Transition
            //Exit 'SW_RESET'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            is_spi_sm_next = state_type_is_spi_sm_IN_WAIT_READY;
            temporalCounter_i1_temp = 32'b00000000000000000000000000000000;
            //Entry 'WAIT_READY'
          end
          else begin
            cnt_clk_temp = cnt_clk;
            if ((cnt_clk - 8'b00000001) > 8'b00000100) begin
              SCK_reg_next = 1'b0;
            end
            else begin
              SCK_reg_next = 1'b1;
            end
            if ((cnt_clk - 8'b00000001) == 8'b00000000) begin
              cnt_clk_temp = 8'd9;
              cnt_bit_temp = cnt_bit;
            end
          end
        end
      state_type_is_spi_sm_IN_WAIT :
        begin
          //During 'WAIT'
          if (temporalCounter_i1_temp >= 32'b00000000000000000000000000001000) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_IDLE;
            //Entry 'IDLE'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd25;
            din_next = data_in;
            cont_read_enabled_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
          else begin
            stop_reg_next = 1'b0;
          end
        end
      state_type_is_spi_sm_IN_WAIT_READY :
        begin
          //During 'WAIT_READY'
          if (temporalCounter_i1_temp >= 32'b00000000000000010000000000000000) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_IDLE;
            //Entry 'IDLE'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd9;
            cnt_bit_temp = 8'd25;
            din_next = data_in;
            cont_read_enabled_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
        end
      default :
        begin
          //case IN_WAIT_nRDY:
          //During 'WAIT_nRDY'
          if (rst) begin
            //Transition
            is_spi_sm_next = state_type_is_spi_sm_IN_RESET;
            temporalCounter_i1_temp = 32'b00000000000000000000000000000000;
            //Entry 'RESET'
            nCS_reg_next = 1'b1;
            SCK_reg_next = 1'b1;
            MOSI_reg_next = 1'b0;
            cnt_clk_temp = 8'd1;
            cnt_bit_temp = 8'd1;
            dout_reg_next = 24'b000000000000000000000000;
            din_next = 24'b000000000000000000000000;
            cont_read_enabled_reg_next = 1'b0;
            dread_out_reg_next = 32'b00000000000000000000000000000000;
            dread_push_reg_next = 1'b0;
            dread_wait_reg_next = 1'b1;
          end
          else begin
            sf_internal_predicateOutput_0 = (temporalCounter_i1_temp >= 32'b00000000000000000000000000001000) && (MISO == 1'b1);
            if (sf_internal_predicateOutput_0) begin
              //Transition
              is_spi_sm_next = state_type_is_spi_sm_IN_CONT_READ_WAIT_nRDY;
              //Entry 'CONT_READ_WAIT_nRDY'
              nCS_reg_next = 1'b0;
              MOSI_reg_next = 1'b0;
              cnt_clk_temp = 8'd9;
              cnt_bit_temp = 8'd33;
              dread_push_reg_next = 1'b0;
              dread_wait_reg_next = 1'b1;
            end
            else begin
              dread_push_reg_next = 1'b0;
            end
          end
        end
    endcase
    cnt_clk_next = cnt_clk_temp - 8'b00000001;
    cnt_bit_next = cnt_bit_temp - 8'b00000001;
    temporalCounter_i1_next = temporalCounter_i1_temp;
  end

  assign nCS = nCS_reg_next;
  assign MOSI = MOSI_reg_next;
  assign SCK = SCK_reg_next;
  assign stop = stop_reg_next;
  assign cont_read_enabled = cont_read_enabled_reg_next;
  assign dread_push = dread_push_reg_next;
  assign dread_out = dread_out_reg_next;
  assign dout = dout_reg_next;
  assign dread_waitdeadOut = dread_wait_reg_next;


  assign dread_wait = 1'b0;



endmodule  // SYSTEM_ip_src_spi_sm

