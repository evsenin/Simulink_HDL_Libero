// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\tb_SYSTEM\SYSTEM_ip_src_SYSTEM.v
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1.25e-08
// Target subsystem base rate: 1.25e-08
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SYSTEM_ip_src_SYSTEM
// Source Path: tb_SYSTEM/SYSTEM
// Hierarchy Level: 0
// 
// Simulink model description for tb_SYSTEM:
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SYSTEM_ip_src_SYSTEM
          (clk,
           reset_x,
           TVS_valid,
           TVS_chan,
           TVS_data,
           SYS_STATUS,
           PWR_STATUS,
           PLL_STATUS,
           XAVIER_SPI2_SCK,
           XAVIER_SPI2_nCS0,
           XAVIER_SPI2_MOSI,
           XAVIER_I2S_CLK,
           XAVIER_I2S_FS,
           XAVIER_I2S_SDIN,
           XAVIER_I2S_SDOUT,
           AXI_CC_SPI_Wr,
           AXI_CC_CONTROL,
           CC_MISO,
           CC_M20,
           axi_wr_s2m_wr_ready,
           axi_wr_s2m_wr_complete,
           axi_rd_s2m_rd_aready,
           axi_rd_s2m_rd_dvalid,
           axi_rd_data,
           XAVIER_SPI1_nCS0,
           XAVIER_SPI1_SCK,
           XAVIER_SPI1_MOSI,
           MonADC_nERROR,
           MonADC_MISO,
           AXI_XAVIER_CONTROL,
           AXI_PWR_CONTROL,
           AXI_DDR_CONTROL,
           AXI_MonADC_SPI_Wr,
           AXI_MonADC_CONTROL,
           AXI_TVS_1000mV,
           AXI_TVS_1800mV,
           AXI_TVS_2500mV,
           AXI_TVS_tempr,
           AXI_SYS_STATUS,
           DDR_RESET,
           PWR_CONTOL,
           AXI_PWR_STATUS,
           XAVIER_SPI2_MISO,
           AXI_PLL_STATUS,
           PPS_OUT,
           AXI_I2S_STATUS,
           CC_nCS,
           CC_nRESET,
           CC_MOSI,
           CC_SCK,
           CC_M43,
           AXI_CC_SPI_Rd,
           AXI_CC_STATUS,
           CC_LOCKED,
           CC_CLK_SEL,
           SysReset_N,
           axi_wr_m2s_wr_addr,
           axi_wr_m2s_wr_len,
           axi_wr_m2s_wr_valid,
           axi_wr_data,
           axi_rd_m2s_rd_addr,
           axi_rd_m2s_rd_len,
           axi_rd_m2s_rd_avalid,
           XAVIER_SPI1_MISO,
           AXI_MonADC_STATUS,
           AXI_MonADC_SPI_Rd,
           AXI_Mon_1V8,
           AXI_Mon_3V3,
           AXI_Mon_CurrentIn,
           AXI_Mon_VoltageIn,
           AXI_Mon_12V,
           MonADC_nCS,
           MonADC_SCK,
           MonADC_MOSI,
           XAVIER_RESET_N,
           XAVIER_SPI1_ENB_MISO);


  input   clk;
  input   reset_x;
  input   TVS_valid;
  input   [1:0] TVS_chan;  // ufix2
  input   signed [15:0] TVS_data;  // int16
  input   [7:0] SYS_STATUS;  // uint8
  input   [7:0] PWR_STATUS;  // uint8
  input   [7:0] PLL_STATUS;  // uint8
  input   XAVIER_SPI2_SCK;
  input   XAVIER_SPI2_nCS0;
  input   XAVIER_SPI2_MOSI;
  input   XAVIER_I2S_CLK;
  input   XAVIER_I2S_FS;
  input   XAVIER_I2S_SDIN;
  input   XAVIER_I2S_SDOUT;
  input   [31:0] AXI_CC_SPI_Wr;  // uint32
  input   [31:0] AXI_CC_CONTROL;  // uint32
  input   CC_MISO;
  input   [2:0] CC_M20;  // ufix3
  input   axi_wr_s2m_wr_ready;
  input   axi_wr_s2m_wr_complete;
  input   axi_rd_s2m_rd_aready;
  input   axi_rd_s2m_rd_dvalid;
  input   [31:0] axi_rd_data;  // uint32
  input   XAVIER_SPI1_nCS0;
  input   XAVIER_SPI1_SCK;
  input   XAVIER_SPI1_MOSI;
  input   MonADC_nERROR;
  input   MonADC_MISO;
  input   [31:0] AXI_XAVIER_CONTROL;  // uint32 Tunable port
  input   [31:0] AXI_PWR_CONTROL;  // uint32 Tunable port
  input   [31:0] AXI_DDR_CONTROL;  // uint32 Tunable port
  input   [31:0] AXI_MonADC_SPI_Wr;  // uint32 Tunable port
  input   [31:0] AXI_MonADC_CONTROL;  // uint32 Tunable port
  output  signed [31:0] AXI_TVS_1000mV;  // int32
  output  signed [31:0] AXI_TVS_1800mV;  // int32
  output  signed [31:0] AXI_TVS_2500mV;  // int32
  output  signed [31:0] AXI_TVS_tempr;  // int32
  output  [7:0] AXI_SYS_STATUS;  // uint8
  output  DDR_RESET;  // ufix1
  output  [7:0] PWR_CONTOL;  // uint8
  output  [7:0] AXI_PWR_STATUS;  // uint8
  output  XAVIER_SPI2_MISO;
  output  [7:0] AXI_PLL_STATUS;  // uint8
  output  PPS_OUT;
  output  [3:0] AXI_I2S_STATUS;  // ufix4
  output  CC_nCS;  // ufix1
  output  CC_nRESET;
  output  CC_MOSI;  // ufix1
  output  CC_SCK;  // ufix1
  output  [1:0] CC_M43;  // ufix2
  output  [31:0] AXI_CC_SPI_Rd;  // uint32
  output  [31:0] AXI_CC_STATUS;  // uint32
  output  CC_LOCKED;
  output  CC_CLK_SEL;
  output  SysReset_N;
  output  [31:0] axi_wr_m2s_wr_addr;  // uint32
  output  [7:0] axi_wr_m2s_wr_len;  // uint8
  output  axi_wr_m2s_wr_valid;
  output  [31:0] axi_wr_data;  // uint32
  output  [31:0] axi_rd_m2s_rd_addr;  // uint32
  output  [7:0] axi_rd_m2s_rd_len;  // uint8
  output  axi_rd_m2s_rd_avalid;
  output  XAVIER_SPI1_MISO;
  output  [31:0] AXI_MonADC_STATUS;  // uint32
  output  [31:0] AXI_MonADC_SPI_Rd;  // uint32
  output  signed [31:0] AXI_Mon_1V8;  // int32
  output  signed [31:0] AXI_Mon_3V3;  // int32
  output  signed [31:0] AXI_Mon_CurrentIn;  // int32
  output  signed [31:0] AXI_Mon_VoltageIn;  // int32
  output  signed [31:0] AXI_Mon_12V;  // int32
  output  MonADC_nCS;
  output  MonADC_SCK;
  output  MonADC_MOSI;
  output  XAVIER_RESET_N;
  output  XAVIER_SPI1_ENB_MISO;


  wire signed [31:0] Temperature_and_Voltage_Sensor_out1;  // int32
  wire signed [31:0] Temperature_and_Voltage_Sensor_out2;  // int32
  wire signed [31:0] Temperature_and_Voltage_Sensor_out3;  // int32
  wire signed [31:0] Temperature_and_Voltage_Sensor_out4;  // int32
  reg [7:0] REG_SYS_STATUS_out1;  // uint8
  wire dtc1;  // ufix1
  reg  REG_DDR_RESET_out1;  // ufix1
  wire [7:0] Extract_Bits13_out1;  // uint8
  reg [7:0] REG_PWR_CONTROL_out1;  // uint8
  reg [7:0] REG_PWR_STATUS_out1;  // uint8
  wire SPISlave_out1;
  wire [63:0] SPISlave_out2;  // ufix64
  wire SPISlave_out3;
  reg [7:0] REG_PLL_STATUS_out1;  // uint8
  wire time_stamp_engine_out1;
  wire [63:0] time_stamp_engine_out2deadOutdeadOut;  // ufix64
  wire [3:0] y;  // ufix4
  reg [3:0] REG_I2S_STATUS_out1;  // ufix4
  wire csna;  // ufix1
  wire csnb;  // ufix1
  wire sck;  // ufix1
  wire resetn;
  wire [1:0] AD9545CC_out5;  // ufix2
  wire AD9545CC_out6;
  wire AD9545CC_out7;
  wire [31:0] AD9545CC_out8;  // uint32
  wire [31:0] AD9545CC_out9;  // uint32
  wire [31:0] spi2axil_out1_wr_addr;  // uint32
  wire [7:0] spi2axil_out1_wr_len;  // uint8
  wire spi2axil_out1_wr_valid;
  wire [31:0] wr_data;  // uint32
  wire spi2axil_out3;
  wire spi2axil_out4;
  wire spi2axil_out5;
  wire [31:0] spi2axil_out6_rd_addr;  // uint32
  wire [7:0] spi2axil_out6_rd_len;  // uint8
  wire spi2axil_out6_rd_avalid;
  wire [15:0] Constant_out1;  // ufix16_En16
  wire AD7173_8_ADC_0_out1;
  wire AD7173_8_ADC_0_out2;
  wire AD7173_8_ADC_0_out3;
  wire [31:0] AD7173_8_ADC_0_out4;  // uint32
  wire [31:0] AD7173_8_ADC_0_out5;  // uint32
  wire signed [31:0] AD7173_8_ADC_0_out6_0;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_1;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_2;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_3;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_4;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_5;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_6;  // sfix32_En31
  wire signed [31:0] AD7173_8_ADC_0_out6_7;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out1;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out2;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out3;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out4;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out5;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out6deadOutdeadOut;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out7deadOutdeadOut;  // sfix32_En31
  wire signed [31:0] AD7173_8_Proc_0_out8deadOutdeadOut;  // sfix32_En31
  wire signed [63:0] Gain2_mul_temp;  // sfix64_En52
  wire signed [31:0] Gain2_out1;  // int32
  reg signed [31:0] Unit_Delay2_out1;  // int32
  wire signed [63:0] Gain3_mul_temp;  // sfix64_En52
  wire signed [31:0] Gain3_out1;  // int32
  reg signed [31:0] Unit_Delay3_out1;  // int32
  wire signed [63:0] Gain_mul_temp;  // sfix64_En46
  wire signed [31:0] Gain_out1;  // int32
  reg signed [31:0] Unit_Delay_out1;  // int32
  wire signed [63:0] Gain1_mul_temp;  // sfix64_En47
  wire signed [31:0] Gain1_out1;  // int32
  reg signed [31:0] Unit_Delay1_out1;  // int32
  wire signed [63:0] Gain4_mul_temp;  // sfix64_En50
  wire signed [31:0] Gain4_out1;  // int32
  reg signed [31:0] Unit_Delay4_out1;  // int32
  wire dtc1_1;  // ufix1
  wire NOT_out1;
  reg  REG_XAVIER_RESET_out1;

  // I (A) = V / (256 * 1200 * 1e-6) = V * 3.387
  // I (mA) = V * 3387
  // V = code * Vref = code * 2.5V
  // CurrentIn(mA) = code * 3387 * 2.5 = code * 8468
  // mA
  // If using External reference 5.5V instead int 2.5V
  // 2.5 -> 5.5
  // VoltageIn(V) = code * 2.5V * 4 = code * 10V
  // VoltageIn(mV) = code * 10000
  // mA
  // mA
  // mA
  // mV


  SYSTEM_ip_src_Temperature_and_Voltage_Sensor u_Temperature_and_Voltage_Sensor (.clk(clk),
                                                                                 .reset_x(reset_x),
                                                                                 .valid(TVS_valid),
                                                                                 .chan(TVS_chan),  // ufix2
                                                                                 .data(TVS_data),  // int16
                                                                                 .alpha1000mV(Temperature_and_Voltage_Sensor_out1),  // int32
                                                                                 .alpha1800mV(Temperature_and_Voltage_Sensor_out2),  // int32
                                                                                 .alpha2500mV(Temperature_and_Voltage_Sensor_out3),  // int32
                                                                                 .tempr(Temperature_and_Voltage_Sensor_out4)  // int32
                                                                                 );
  assign AXI_TVS_1000mV = Temperature_and_Voltage_Sensor_out1;

  assign AXI_TVS_1800mV = Temperature_and_Voltage_Sensor_out2;

  assign AXI_TVS_2500mV = Temperature_and_Voltage_Sensor_out3;

  assign AXI_TVS_tempr = Temperature_and_Voltage_Sensor_out4;

  always @(posedge clk or posedge reset_x)
    begin : REG_SYS_STATUS_process
      if (reset_x == 1'b1) begin
        REG_SYS_STATUS_out1 <= 8'b00000000;
      end
      else begin
        REG_SYS_STATUS_out1 <= SYS_STATUS;
      end
    end


  assign AXI_SYS_STATUS = REG_SYS_STATUS_out1;

  assign dtc1 = AXI_DDR_CONTROL[0];


  always @(posedge clk or posedge reset_x)
    begin : REG_DDR_RESET_process
      if (reset_x == 1'b1) begin
        REG_DDR_RESET_out1 <= 1'b0;
      end
      else begin
        REG_DDR_RESET_out1 <= dtc1;
      end
    end


  assign DDR_RESET = REG_DDR_RESET_out1;

  assign Extract_Bits13_out1 = AXI_PWR_CONTROL[7:0];


  always @(posedge clk or posedge reset_x)
    begin : REG_PWR_CONTROL_process
      if (reset_x == 1'b1) begin
        REG_PWR_CONTROL_out1 <= 8'b00000000;
      end
      else begin
        REG_PWR_CONTROL_out1 <= Extract_Bits13_out1;
      end
    end


  assign PWR_CONTOL = REG_PWR_CONTROL_out1;

  always @(posedge clk or posedge reset_x)
    begin : REG_PWR_STATUS_process
      if (reset_x == 1'b1) begin
        REG_PWR_STATUS_out1 <= 8'b00000000;
      end
      else begin
        REG_PWR_STATUS_out1 <= PWR_STATUS;
      end
    end


  assign AXI_PWR_STATUS = REG_PWR_STATUS_out1;

  SYSTEM_ip_src_SPISlave u_SPISlave (.clk(clk),
                                     .reset_x(reset_x),
                                     .nCS0(XAVIER_SPI2_nCS0),
                                     .SCK(XAVIER_SPI2_SCK),
                                     .MOSI(XAVIER_SPI2_MOSI),
                                     .tstamp_valid(SPISlave_out1),
                                     .tstamp_value(SPISlave_out2),  // ufix64
                                     .MISO(SPISlave_out3)
                                     );
  assign XAVIER_SPI2_MISO = SPISlave_out3;

  always @(posedge clk or posedge reset_x)
    begin : REG_PLL_STATUS_process
      if (reset_x == 1'b1) begin
        REG_PLL_STATUS_out1 <= 8'b00000000;
      end
      else begin
        REG_PLL_STATUS_out1 <= PLL_STATUS;
      end
    end


  assign AXI_PLL_STATUS = REG_PLL_STATUS_out1;

  SYSTEM_ip_src_time_stamp_engine u_time_stamp_engine (.clk(clk),
                                                       .reset_x(reset_x),
                                                       .tstamp_ready(SPISlave_out1),
                                                       .tstamp_value(SPISlave_out2),  // ufix64
                                                       .tstamp_strobe(time_stamp_engine_out1),
                                                       .time_stamp_tick(time_stamp_engine_out2deadOutdeadOut)  // ufix64
                                                       );
  assign PPS_OUT = time_stamp_engine_out1;

  assign y = {XAVIER_I2S_CLK, XAVIER_I2S_FS, XAVIER_I2S_SDIN, XAVIER_I2S_SDOUT};


  always @(posedge clk or posedge reset_x)
    begin : REG_I2S_STATUS_process
      if (reset_x == 1'b1) begin
        REG_I2S_STATUS_out1 <= 4'b0000;
      end
      else begin
        REG_I2S_STATUS_out1 <= y;
      end
    end


  assign AXI_I2S_STATUS = REG_I2S_STATUS_out1;

  SYSTEM_ip_src_AD9545CC u_AD9545CC (.clk(clk),
                                     .reset_x(reset_x),
                                     .AXI_SPI_Wr(AXI_CC_SPI_Wr),  // uint32
                                     .AXI_CONTROL(AXI_CC_CONTROL),  // uint32
                                     .MISO(CC_MISO),
                                     .M20(CC_M20),  // ufix3
                                     .nCS(csna),  // ufix1
                                     .SCK(csnb),  // ufix1
                                     .MOSI(sck),  // ufix1
                                     .nRESET(resetn),
                                     .M43(AD9545CC_out5),  // ufix2
                                     .LOCKED(AD9545CC_out6),
                                     .CLK_SELECT(AD9545CC_out7),
                                     .AXI_SPI_Rd(AD9545CC_out8),  // uint32
                                     .AXI_STATUS(AD9545CC_out9)  // uint32
                                     );
  assign CC_nCS = csna;

  assign CC_nRESET = resetn;

  assign CC_MOSI = sck;

  assign CC_SCK = csnb;

  assign CC_M43 = AD9545CC_out5;

  assign AXI_CC_SPI_Rd = AD9545CC_out8;

  assign AXI_CC_STATUS = AD9545CC_out9;

  assign CC_LOCKED = AD9545CC_out6;

  assign CC_CLK_SEL = AD9545CC_out7;

  SYSTEM_ip_src_spi2axil u_spi2axil (.clk(clk),
                                     .reset_x(reset_x),
                                     .axi_rd_s2m_rd_aready(axi_rd_s2m_rd_aready),
                                     .axi_rd_s2m_rd_dvalid(axi_rd_s2m_rd_dvalid),
                                     .axi_rd_data(axi_rd_data),  // uint32
                                     .nCS(XAVIER_SPI1_nCS0),
                                     .SCK(XAVIER_SPI1_SCK),
                                     .MOSI(XAVIER_SPI1_MOSI),
                                     .axi_wr_s2m_wr_ready(axi_wr_s2m_wr_ready),
                                     .axi_wr_s2m_wr_complete(axi_wr_s2m_wr_complete),
                                     .axi_wr_m2s_wr_addr(spi2axil_out1_wr_addr),  // uint32
                                     .axi_wr_m2s_wr_len(spi2axil_out1_wr_len),  // uint8
                                     .axi_wr_m2s_wr_valid(spi2axil_out1_wr_valid),
                                     .axi_wr_data(wr_data),  // uint32
                                     .MISO(spi2axil_out3),
                                     .ENB_MISO(spi2axil_out4),
                                     .EXT_RST_N(spi2axil_out5),
                                     .axi_rd_m2s_rd_addr(spi2axil_out6_rd_addr),  // uint32
                                     .axi_rd_m2s_rd_len(spi2axil_out6_rd_len),  // uint8
                                     .axi_rd_m2s_rd_avalid(spi2axil_out6_rd_avalid)
                                     );
  assign SysReset_N = spi2axil_out5;

  assign axi_wr_m2s_wr_addr = spi2axil_out1_wr_addr;

  assign axi_wr_m2s_wr_len = spi2axil_out1_wr_len;

  assign axi_wr_m2s_wr_valid = spi2axil_out1_wr_valid;

  assign axi_wr_data = wr_data;

  assign axi_rd_m2s_rd_addr = spi2axil_out6_rd_addr;

  assign axi_rd_m2s_rd_len = spi2axil_out6_rd_len;

  assign axi_rd_m2s_rd_avalid = spi2axil_out6_rd_avalid;

  assign XAVIER_SPI1_MISO = spi2axil_out3;

  assign Constant_out1 = 16'b0000001000000000;


  SYSTEM_ip_src_AD7173_8_ADC_0 u_AD7173_8_ADC_0 (.clk(clk),
                                                 .reset_x(reset_x),
                                                 .DATA_IN(AXI_MonADC_SPI_Wr),  // uint32
                                                 .MISO(MonADC_MISO),
                                                 .CONTROL_IN(AXI_MonADC_CONTROL),  // uint32
                                                 .nERROR(MonADC_nERROR),
                                                 .FilterCoeff(Constant_out1),  // ufix16_En16
                                                 .nCS(AD7173_8_ADC_0_out1),
                                                 .SCK(AD7173_8_ADC_0_out2),
                                                 .MOSI(AD7173_8_ADC_0_out3),
                                                 .DATA_OUT(AD7173_8_ADC_0_out4),  // uint32
                                                 .STATUS_OUT(AD7173_8_ADC_0_out5),  // uint32
                                                 .channnels_0(AD7173_8_ADC_0_out6_0),  // sfix32_En31
                                                 .channnels_1(AD7173_8_ADC_0_out6_1),  // sfix32_En31
                                                 .channnels_2(AD7173_8_ADC_0_out6_2),  // sfix32_En31
                                                 .channnels_3(AD7173_8_ADC_0_out6_3),  // sfix32_En31
                                                 .channnels_4(AD7173_8_ADC_0_out6_4),  // sfix32_En31
                                                 .channnels_5(AD7173_8_ADC_0_out6_5),  // sfix32_En31
                                                 .channnels_6(AD7173_8_ADC_0_out6_6),  // sfix32_En31
                                                 .channnels_7(AD7173_8_ADC_0_out6_7)  // sfix32_En31
                                                 );
  assign AXI_MonADC_STATUS = AD7173_8_ADC_0_out5;

  assign AXI_MonADC_SPI_Rd = AD7173_8_ADC_0_out4;

  SYSTEM_ip_src_AD7173_8_Proc_0 u_AD7173_8_Proc_0 (.channels_0(AD7173_8_ADC_0_out6_0),  // sfix32_En31
                                                   .channels_1(AD7173_8_ADC_0_out6_1),  // sfix32_En31
                                                   .channels_2(AD7173_8_ADC_0_out6_2),  // sfix32_En31
                                                   .channels_3(AD7173_8_ADC_0_out6_3),  // sfix32_En31
                                                   .channels_4(AD7173_8_ADC_0_out6_4),  // sfix32_En31
                                                   .channels_5(AD7173_8_ADC_0_out6_5),  // sfix32_En31
                                                   .channels_6(AD7173_8_ADC_0_out6_6),  // sfix32_En31
                                                   .channels_7(AD7173_8_ADC_0_out6_7),  // sfix32_En31
                                                   .ch0(AD7173_8_Proc_0_out1),  // sfix32_En31
                                                   .ch1(AD7173_8_Proc_0_out2),  // sfix32_En31
                                                   .ch2(AD7173_8_Proc_0_out3),  // sfix32_En31
                                                   .ch3(AD7173_8_Proc_0_out4),  // sfix32_En31
                                                   .ch4(AD7173_8_Proc_0_out5),  // sfix32_En31
                                                   .ch5(AD7173_8_Proc_0_out6deadOutdeadOut),  // sfix32_En31
                                                   .ch6(AD7173_8_Proc_0_out7deadOutdeadOut),  // sfix32_En31
                                                   .ch7(AD7173_8_Proc_0_out8deadOutdeadOut)  // sfix32_En31
                                                   );
  assign Gain2_mul_temp = 32'sb01111101000000000000000000000000 * AD7173_8_Proc_0_out1;
  assign Gain2_out1 = {{20{Gain2_mul_temp[63]}}, Gain2_mul_temp[63:52]};


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay2_process
      if (reset_x == 1'b1) begin
        Unit_Delay2_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        Unit_Delay2_out1 <= Gain2_out1;
      end
    end


  assign AXI_Mon_1V8 = Unit_Delay2_out1;

  assign Gain3_mul_temp = 32'sb01111101000000000000000000000000 * AD7173_8_Proc_0_out2;
  assign Gain3_out1 = {{20{Gain3_mul_temp[63]}}, Gain3_mul_temp[63:52]};


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay3_process
      if (reset_x == 1'b1) begin
        Unit_Delay3_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        Unit_Delay3_out1 <= Gain3_out1;
      end
    end


  assign AXI_Mon_3V3 = Unit_Delay3_out1;

  assign Gain_mul_temp = 32'sb01010101111100000000000000000000 * AD7173_8_Proc_0_out3;
  assign Gain_out1 = {{14{Gain_mul_temp[63]}}, Gain_mul_temp[63:46]};


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay_process
      if (reset_x == 1'b1) begin
        Unit_Delay_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        Unit_Delay_out1 <= Gain_out1;
      end
    end


  assign AXI_Mon_CurrentIn = Unit_Delay_out1;

  assign Gain1_mul_temp = 32'sb01010101111100000000000000000000 * AD7173_8_Proc_0_out4;
  assign Gain1_out1 = {{15{Gain1_mul_temp[63]}}, Gain1_mul_temp[63:47]};


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay1_process
      if (reset_x == 1'b1) begin
        Unit_Delay1_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        Unit_Delay1_out1 <= Gain1_out1;
      end
    end


  assign AXI_Mon_VoltageIn = Unit_Delay1_out1;

  assign Gain4_mul_temp = 32'sb01111101000000000000000000000000 * AD7173_8_Proc_0_out5;
  assign Gain4_out1 = {{18{Gain4_mul_temp[63]}}, Gain4_mul_temp[63:50]};


  always @(posedge clk or posedge reset_x)
    begin : Unit_Delay4_process
      if (reset_x == 1'b1) begin
        Unit_Delay4_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        Unit_Delay4_out1 <= Gain4_out1;
      end
    end


  assign AXI_Mon_12V = Unit_Delay4_out1;

  assign MonADC_nCS = AD7173_8_ADC_0_out1;

  assign MonADC_SCK = AD7173_8_ADC_0_out2;

  assign MonADC_MOSI = AD7173_8_ADC_0_out3;

  assign dtc1_1 = AXI_XAVIER_CONTROL[0];


  assign NOT_out1 =  ~ dtc1_1;


  always @(posedge clk or posedge reset_x)
    begin : REG_XAVIER_RESET_process
      if (reset_x == 1'b1) begin
        REG_XAVIER_RESET_out1 <= 1'b0;
      end
      else begin
        REG_XAVIER_RESET_out1 <= NOT_out1;
      end
    end


  assign XAVIER_RESET_N = REG_XAVIER_RESET_out1;

  assign XAVIER_SPI1_ENB_MISO = spi2axil_out4;

endmodule  // SYSTEM_ip_src_SYSTEM

