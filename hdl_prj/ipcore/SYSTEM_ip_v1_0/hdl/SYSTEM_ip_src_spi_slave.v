// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\tb_SYSTEM\SYSTEM_ip_src_spi_slave.v
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// Copyright (c) 2023, Alexei Evsenin, evsenin@gmail.com
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SYSTEM_ip_src_spi_slave
// Source Path: tb_SYSTEM/SYSTEM/SPISlave/spi_slave
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SYSTEM_ip_src_spi_slave
          (clk,
           reset_x,
           nCS,
           MOSI,
           SCK,
           rdata,
           MISO,
           wvalid,
           rvalid,
           wdata,
           waddr,
           raddr);

  parameter [7:0] nbit = 32;  // uint8
  // Default encoded enumeration values for type state_type_is_spi_slave
  parameter state_type_is_spi_slave_IN_CLK_HIGH_WAIT = 3'd0, state_type_is_spi_slave_IN_CLK_LOW_WAIT = 3'd1, state_type_is_spi_slave_IN_IDLE = 3'd2, state_type_is_spi_slave_IN_READY = 3'd3, state_type_is_spi_slave_IN_RESET = 3'd4;

  input   clk;
  input   reset_x;
  input   nCS;
  input   MOSI;
  input   SCK;
  input   [31:0] rdata;  // uint32
  output  MISO;
  output  wvalid;
  output  rvalid;
  output  [31:0] wdata;  // uint32
  output  [31:0] waddr;  // uint32
  output  [31:0] raddr;  // uint32


  reg [2:0] is_spi_slave;  // uint8
  reg [7:0] cbit;  // uint8
  reg [31:0] drecvd;  // uint32
  reg  next_data_write;
  reg [7:0] cword;  // uint8
  reg  MISO_reg;
  reg  wvalid_reg;
  reg  rvalid_reg;
  reg [31:0] wdata_reg;  // uint32
  reg [31:0] waddr_reg;  // uint32
  reg [31:0] raddr_reg;  // uint32
  reg [2:0] is_spi_slave_next;  // enum type state_type_is_spi_slave (5 enums)
  reg [7:0] cbit_next;  // uint8
  reg [31:0] drecvd_next;  // uint32
  reg  next_data_write_next;
  reg [7:0] cword_next;  // uint8
  reg  MISO_reg_next;
  reg  wvalid_reg_next;
  reg  rvalid_reg_next;
  reg [31:0] wdata_reg_next;  // uint32
  reg [31:0] waddr_reg_next;  // uint32
  reg [31:0] raddr_reg_next;  // uint32
  reg [7:0] bm1;  // uint8
  reg [31:0] c;  // uint32
  reg [31:0] c_0;  // uint32
  reg [31:0] c_1;  // uint32
  reg [7:0] bm1_0;  // uint8
  reg [31:0] mask;  // uint32
  reg [7:0] bm1_1;  // uint8
  reg [7:0] bm1_2;  // uint8
  reg [7:0] bm1_3;  // uint8
  reg [7:0] bm1_4;  // uint8
  reg [31:0] mask_0;  // uint32
  reg [7:0] bm1_5;  // uint8
  reg [31:0] mask_1;  // uint32
  reg [7:0] bm1_6;  // uint8
  reg [31:0] mask_2;  // uint32
  reg [7:0] cbit_temp;  // uint8
  reg [8:0] add_temp;  // ufix9
  reg [7:0] add_cast;  // uint8
  reg [8:0] add_temp_0;  // ufix9
  reg [8:0] add_temp_1;  // ufix9
  reg [8:0] add_temp_2;  // ufix9
  reg [7:0] add_cast_0;  // uint8
  reg [8:0] add_temp_3;  // ufix9
  reg [8:0] add_temp_4;  // ufix9
  reg [7:0] cast;  // uint8
  reg [8:0] add_temp_5;  // ufix9
  reg [7:0] sub_cast;  // uint8
  reg [8:0] add_temp_6;  // ufix9
  reg [32:0] add_temp_7;  // ufix33
  reg [8:0] add_temp_8;  // ufix9
  reg [7:0] add_cast_1;  // uint8
  reg [32:0] add_temp_9;  // ufix33
  reg [8:0] add_temp_10;  // ufix9
  reg [7:0] sub_cast_0;  // uint8
  reg [32:0] add_temp_11;  // ufix33
  reg [5:0] add_cast_2;  // ufix6
  reg [5:0] sub_temp;  // ufix6
  reg [8:0] add_temp_12;  // ufix9
  reg [7:0] sub_cast_1;  // uint8
  reg [31:0] t_0;  // ufix32
  reg [1:0] t_1;  // ufix2
  reg [31:0] t_2;  // ufix32
  reg [1:0] t_3;  // ufix2
  reg [31:0] t_4;  // ufix32
  reg [1:0] t_5;  // ufix2
  reg signed [31:0] t_6;  // int32
  reg signed [31:0] t_7;  // int32
  reg signed [31:0] t_8;  // int32
  reg signed [31:0] t_9;  // int32
  reg [8:0] t_10;  // ufix9
  reg [8:0] t_11;  // ufix9
  reg [8:0] t_12;  // ufix9
  reg [8:0] t_13;  // ufix9
  reg [8:0] t_14;  // ufix9
  reg [8:0] t_15;  // ufix9
  reg [8:0] t_16;  // ufix9
  reg [8:0] t_17;  // ufix9
  reg [32:0] t_18;  // ufix33
  reg [8:0] t_19;  // ufix9
  reg [32:0] t_20;  // ufix33
  reg [8:0] t_21;  // ufix9
  reg [32:0] t_22;  // ufix33
  reg [8:0] t_23;  // ufix9


  always @(posedge clk or posedge reset_x)
    begin : spi_slave_process
      if (reset_x == 1'b1) begin
        //Entry: SYSTEM/SPISlave/spi_slave
        //Entry Internal: SYSTEM/SPISlave/spi_slave
        //Transition
        is_spi_slave <= state_type_is_spi_slave_IN_RESET;
        //Entry 'RESET'
        MISO_reg <= 1'b0;
        cbit <= 8'd0;
        cword <= 8'd0;
        drecvd <= 32'd0;
        next_data_write <= 1'b0;
        wvalid_reg <= 1'b0;
        waddr_reg <= 32'd0;
        wdata_reg <= 32'd0;
        rvalid_reg <= 1'b0;
        raddr_reg <= 32'd0;
      end
      else begin
        is_spi_slave <= is_spi_slave_next;
        cbit <= cbit_next;
        drecvd <= drecvd_next;
        next_data_write <= next_data_write_next;
        cword <= cword_next;
        MISO_reg <= MISO_reg_next;
        wvalid_reg <= wvalid_reg_next;
        rvalid_reg <= rvalid_reg_next;
        wdata_reg <= wdata_reg_next;
        waddr_reg <= waddr_reg_next;
        raddr_reg <= raddr_reg_next;
      end
    end

  always @(MISO_reg, MOSI, SCK, cbit, cword, drecvd, is_spi_slave, nCS, next_data_write,
       raddr_reg, rdata, rvalid_reg, waddr_reg, wdata_reg, wvalid_reg) begin
    bm1 = 8'd0;
    bm1_0 = 8'd0;
    mask = 32'd0;
    bm1_1 = 8'd0;
    bm1_3 = 8'd0;
    bm1_4 = 8'd0;
    mask_0 = 32'd0;
    c = 32'd0;
    bm1_5 = 8'd0;
    mask_1 = 32'd0;
    c_0 = 32'd0;
    bm1_6 = 8'd0;
    mask_2 = 32'd0;
    c_1 = 32'd0;
    add_temp = 9'b000000000;
    add_temp_0 = 9'b000000000;
    add_temp_1 = 9'b000000000;
    add_temp_2 = 9'b000000000;
    add_temp_3 = 9'b000000000;
    add_temp_4 = 9'b000000000;
    add_temp_5 = 9'b000000000;
    add_temp_6 = 9'b000000000;
    add_temp_7 = 33'h000000000;
    add_temp_8 = 9'b000000000;
    add_temp_9 = 33'h000000000;
    add_temp_10 = 9'b000000000;
    add_temp_11 = 33'h000000000;
    sub_temp = 6'b000000;
    add_temp_12 = 9'b000000000;
    t_0 = 32'b00000000000000000000000000000000;
    t_2 = 32'b00000000000000000000000000000000;
    t_4 = 32'b00000000000000000000000000000000;
    bm1_2 = 8'd0;
    add_cast = 8'd0;
    add_cast_0 = 8'd0;
    cast = 8'd0;
    sub_cast = 8'd0;
    add_cast_1 = 8'd0;
    sub_cast_0 = 8'd0;
    add_cast_2 = 6'b000000;
    sub_cast_1 = 8'd0;
    t_1 = 2'b00;
    t_3 = 2'b00;
    t_5 = 2'b00;
    t_6 = 32'sd0;
    t_7 = 32'sd0;
    t_8 = 32'sd0;
    t_9 = 32'sd0;
    t_10 = 9'b000000000;
    t_11 = 9'b000000000;
    t_12 = 9'b000000000;
    t_13 = 9'b000000000;
    t_14 = 9'b000000000;
    t_15 = 9'b000000000;
    t_16 = 9'b000000000;
    t_17 = 9'b000000000;
    t_18 = 33'h000000000;
    t_19 = 9'b000000000;
    t_20 = 33'h000000000;
    t_21 = 9'b000000000;
    t_22 = 33'h000000000;
    t_23 = 9'b000000000;
    cbit_temp = cbit;
    MISO_reg_next = MISO_reg;
    wvalid_reg_next = wvalid_reg;
    rvalid_reg_next = rvalid_reg;
    wdata_reg_next = wdata_reg;
    waddr_reg_next = waddr_reg;
    raddr_reg_next = raddr_reg;
    is_spi_slave_next = is_spi_slave;
    drecvd_next = drecvd;
    next_data_write_next = next_data_write;
    cword_next = cword;
    //Gateway: SYSTEM/SPISlave/spi_slave
    //During: SYSTEM/SPISlave/spi_slave
    case ( is_spi_slave)
      state_type_is_spi_slave_IN_CLK_HIGH_WAIT :
        begin
          //During 'CLK_HIGH_WAIT'
          if (nCS || (cbit == nbit)) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave_IN_READY;
            //Entry 'READY'
            if (cbit == nbit) begin
              if (cword == 8'b00000000) begin
                t_4 = drecvd & 32'b00000000000000000000000000000011;
                t_5 = t_4[1:0];
                if (t_5 == 2'b00) begin
                  waddr_reg_next = drecvd & 32'd4294967292;
                  next_data_write_next = 1'b1;
                end
                else begin
                  rvalid_reg_next = 1'b1;
                  raddr_reg_next = drecvd & 32'd4294967292;
                  next_data_write_next = 1'b0;
                end
              end
              else if (next_data_write) begin
                wvalid_reg_next = 1'b1;
                wdata_reg_next = drecvd;
                if (cword > 8'b00000001) begin
                  t_20 = {1'b0, waddr_reg};
                  add_temp_9 = t_20 + 33'h000000004;
                  if (add_temp_9[32] != 1'b0) begin
                    waddr_reg_next = 32'b11111111111111111111111111111111;
                  end
                  else begin
                    waddr_reg_next = add_temp_9[31:0];
                  end
                end
              end
            end
            t_14 = {1'b0, cword};
            add_temp_3 = t_14 + 9'b000000001;
            if (add_temp_3[8] != 1'b0) begin
              cword_next = 8'b11111111;
            end
            else begin
              cword_next = add_temp_3[7:0];
            end
            cbit_temp = 8'd0;
          end
          else if (SCK) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave_IN_CLK_LOW_WAIT;
            //Entry 'CLK_LOW_WAIT'
          end
          else if (cbit < nbit) begin
            t_10 = {1'b0, cbit};
            add_temp = t_10 + 9'b000000001;
            if (add_temp[8] != 1'b0) begin
              add_cast = 8'b11111111;
            end
            else begin
              add_cast = add_temp[7:0];
            end
            bm1_0 = add_cast + 8'd255;
            t_6 = {24'b0, bm1_0};
            mask = 32'b00000000000000000000000000000001 <<< t_6;
            if (MOSI) begin
              drecvd_next = drecvd | mask;
            end
            else begin
              drecvd_next = drecvd & ( ~ mask);
            end
            t_16 = {1'b0, cbit};
            add_temp_5 = t_16 + 9'b000000001;
            if (add_temp_5[8] != 1'b0) begin
              sub_cast = 8'b11111111;
            end
            else begin
              sub_cast = add_temp_5[7:0];
            end
            bm1 = sub_cast - 8'b00000001;
            MISO_reg_next = rdata[bm1] != 1'b0;
          end
        end
      state_type_is_spi_slave_IN_CLK_LOW_WAIT :
        begin
          //During 'CLK_LOW_WAIT'
          if ( ! SCK) begin
            //Transition
            //Exit 'CLK_LOW_WAIT'
            t_11 = {1'b0, cbit};
            add_temp_0 = t_11 + 9'b000000001;
            if (add_temp_0[8] != 1'b0) begin
              cbit_temp = 8'b11111111;
            end
            else begin
              cbit_temp = add_temp_0[7:0];
            end
            is_spi_slave_next = state_type_is_spi_slave_IN_CLK_HIGH_WAIT;
            //Entry 'CLK_HIGH_WAIT'
            if (cbit_temp < nbit) begin
              bm1_5 = (cbit_temp + 8'd1) + 8'd255;
              t_8 = {24'b0, bm1_5};
              mask_1 = 32'b00000000000000000000000000000001 <<< t_8;
              if (MOSI) begin
                c_0 = drecvd | mask_1;
              end
              else begin
                c_0 = drecvd & ( ~ mask_1);
              end
              drecvd_next = c_0;
              add_cast_2 = cbit_temp[5:0];
              sub_temp = (add_cast_2 + 6'b000001) - 6'b000001;
              bm1_2 = {2'b0, sub_temp};
              MISO_reg_next = rdata[bm1_2] != 1'b0;
            end
          end
          else if (nCS) begin
            //Transition
            //Exit 'CLK_LOW_WAIT'
            is_spi_slave_next = state_type_is_spi_slave_IN_READY;
            //Entry 'READY'
            t_15 = {1'b0, cbit};
            add_temp_4 = t_15 + 9'b000000001;
            if (add_temp_4[8] != 1'b0) begin
              cast = 8'b11111111;
            end
            else begin
              cast = add_temp_4[7:0];
            end
            if (cast == nbit) begin
              if (cword == 8'b00000000) begin
                t_2 = drecvd & 32'b00000000000000000000000000000011;
                t_3 = t_2[1:0];
                if (t_3 == 2'b00) begin
                  waddr_reg_next = drecvd & 32'd4294967292;
                  next_data_write_next = 1'b1;
                end
                else begin
                  rvalid_reg_next = 1'b1;
                  raddr_reg_next = drecvd & 32'd4294967292;
                  next_data_write_next = 1'b0;
                end
              end
              else if (next_data_write) begin
                wvalid_reg_next = 1'b1;
                wdata_reg_next = drecvd;
                if (cword > 8'b00000001) begin
                  t_22 = {1'b0, waddr_reg};
                  add_temp_11 = t_22 + 33'h000000004;
                  if (add_temp_11[32] != 1'b0) begin
                    waddr_reg_next = 32'b11111111111111111111111111111111;
                  end
                  else begin
                    waddr_reg_next = add_temp_11[31:0];
                  end
                end
              end
            end
            t_17 = {1'b0, cword};
            add_temp_6 = t_17 + 9'b000000001;
            if (add_temp_6[8] != 1'b0) begin
              cword_next = 8'b11111111;
            end
            else begin
              cword_next = add_temp_6[7:0];
            end
            cbit_temp = 8'd0;
          end
        end
      state_type_is_spi_slave_IN_IDLE :
        begin
          //During 'IDLE'
          if ( ! nCS) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave_IN_CLK_HIGH_WAIT;
            //Entry 'CLK_HIGH_WAIT'
            if (cbit < nbit) begin
              t_13 = {1'b0, cbit};
              add_temp_2 = t_13 + 9'b000000001;
              if (add_temp_2[8] != 1'b0) begin
                add_cast_0 = 8'b11111111;
              end
              else begin
                add_cast_0 = add_temp_2[7:0];
              end
              bm1_4 = add_cast_0 + 8'd255;
              t_7 = {24'b0, bm1_4};
              mask_0 = 32'b00000000000000000000000000000001 <<< t_7;
              if (MOSI) begin
                c = drecvd | mask_0;
              end
              else begin
                c = drecvd & ( ~ mask_0);
              end
              drecvd_next = c;
              t_21 = {1'b0, cbit};
              add_temp_10 = t_21 + 9'b000000001;
              if (add_temp_10[8] != 1'b0) begin
                sub_cast_0 = 8'b11111111;
              end
              else begin
                sub_cast_0 = add_temp_10[7:0];
              end
              bm1_1 = sub_cast_0 - 8'b00000001;
              MISO_reg_next = rdata[bm1_1] != 1'b0;
            end
          end
          else begin
            cbit_temp = 8'd0;
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            next_data_write_next = 1'b0;
            cword_next = 8'd0;
            MISO_reg_next = 1'b0;
          end
        end
      state_type_is_spi_slave_IN_READY :
        begin
          //During 'READY'
          if (nCS) begin
            //Transition
            is_spi_slave_next = state_type_is_spi_slave_IN_IDLE;
            //Entry 'IDLE'
            cbit_temp = 8'd0;
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            next_data_write_next = 1'b0;
            cword_next = 8'd0;
            MISO_reg_next = 1'b0;
          end
          else if ( ! nCS) begin
            //Transition
            wvalid_reg_next = 1'b0;
            rvalid_reg_next = 1'b0;
            is_spi_slave_next = state_type_is_spi_slave_IN_CLK_HIGH_WAIT;
            //Entry 'CLK_HIGH_WAIT'
            if (cbit < nbit) begin
              t_19 = {1'b0, cbit};
              add_temp_8 = t_19 + 9'b000000001;
              if (add_temp_8[8] != 1'b0) begin
                add_cast_1 = 8'b11111111;
              end
              else begin
                add_cast_1 = add_temp_8[7:0];
              end
              bm1_6 = add_cast_1 + 8'd255;
              t_9 = {24'b0, bm1_6};
              mask_2 = 32'b00000000000000000000000000000001 <<< t_9;
              if (MOSI) begin
                c_1 = drecvd | mask_2;
              end
              else begin
                c_1 = drecvd & ( ~ mask_2);
              end
              drecvd_next = c_1;
              t_23 = {1'b0, cbit};
              add_temp_12 = t_23 + 9'b000000001;
              if (add_temp_12[8] != 1'b0) begin
                sub_cast_1 = 8'b11111111;
              end
              else begin
                sub_cast_1 = add_temp_12[7:0];
              end
              bm1_3 = sub_cast_1 - 8'b00000001;
              MISO_reg_next = rdata[bm1_3] != 1'b0;
            end
          end
          else begin
            if (cbit == nbit) begin
              if (cword == 8'b00000000) begin
                t_0 = drecvd & 32'b00000000000000000000000000000011;
                t_1 = t_0[1:0];
                if (t_1 == 2'b00) begin
                  waddr_reg_next = drecvd & 32'd4294967292;
                  next_data_write_next = 1'b1;
                end
                else begin
                  rvalid_reg_next = 1'b1;
                  raddr_reg_next = drecvd & 32'd4294967292;
                  next_data_write_next = 1'b0;
                end
              end
              else if (next_data_write) begin
                wvalid_reg_next = 1'b1;
                wdata_reg_next = drecvd;
                if (cword > 8'b00000001) begin
                  t_18 = {1'b0, waddr_reg};
                  add_temp_7 = t_18 + 33'h000000004;
                  if (add_temp_7[32] != 1'b0) begin
                    waddr_reg_next = 32'b11111111111111111111111111111111;
                  end
                  else begin
                    waddr_reg_next = add_temp_7[31:0];
                  end
                end
              end
            end
            t_12 = {1'b0, cword};
            add_temp_1 = t_12 + 9'b000000001;
            if (add_temp_1[8] != 1'b0) begin
              cword_next = 8'b11111111;
            end
            else begin
              cword_next = add_temp_1[7:0];
            end
            cbit_temp = 8'd0;
          end
        end
      default :
        begin
          //case IN_RESET:
          //During 'RESET'
          //Transition
          is_spi_slave_next = state_type_is_spi_slave_IN_IDLE;
          //Entry 'IDLE'
          cbit_temp = 8'd0;
          wvalid_reg_next = 1'b0;
          rvalid_reg_next = 1'b0;
          next_data_write_next = 1'b0;
          cword_next = 8'd0;
          MISO_reg_next = 1'b0;
        end
    endcase
    cbit_next = cbit_temp;
  end

  assign MISO = MISO_reg_next;
  assign wvalid = wvalid_reg_next;
  assign rvalid = rvalid_reg_next;
  assign wdata = wdata_reg_next;
  assign waddr = waddr_reg_next;
  assign raddr = raddr_reg_next;


endmodule  // SYSTEM_ip_src_spi_slave

